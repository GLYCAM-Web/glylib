<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GLYLIB: src/parse_amber_prmtop.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../modules.html">Modules</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../dirs.html">Directories</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="../../dir_000002.html">src</a></div>
<h1>parse_amber_prmtop.c</h1><a href="../../db/d7d/parse__amber__prmtop_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/* File parse_amber_prmtop.c begun on 20080610 by BLFoley</span>
00002 <span class="comment"> * Purpose: parse entries from prmtop file (already read in) into</span>
00003 <span class="comment"> *      appropriate data locations within an assembly</span>
00004 <span class="comment"> *      Also adds the prmtop P to the assembly's void pointer</span>
00005 <span class="comment"> */</span>
00006 <span class="preprocessor">#include "<a class="code" href="../../d6/d78/amber__prmtop_8h.html">AMBER/amber_prmtop.h</a>"</span>
00007 
<a name="l00008"></a><a class="code" href="../../db/d7d/parse__amber__prmtop_8c.html#a0">00008</a> <a class="code" href="../../db/dac/structassembly.html">assembly</a> <a class="code" href="../../db/d7d/parse__amber__prmtop_8c.html#a0">parse_amber_prmtop</a>(<a class="code" href="../../de/de7/structamber__prmtop.html">amber_prmtop</a> *P){
00009 <a class="code" href="../../db/dac/structassembly.html">assembly</a> A;
00010 <span class="keywordtype">int</span> *ICO,nICO;
00011 <span class="keywordtype">int</span> pa=0,pb=0,pc=0,pd=0,pA1=0,pA2=0,pA3,pA4,pI1=0;
00012 <span class="keywordtype">int</span> NextRes=0,nummol=0,*resi; <span class="comment">// more utility integers</span>
00013 <span class="keywordtype">int</span> sa=0,sr=0,sm=0,ta=0,tr=0,tm=0;
00014 <span class="keywordtype">int</span> IPTRES=0,NSPM=0,NSPSOL=0,*NSP; <span class="comment">// solvent/solute info &amp; #atoms per molecule</span>
00015 <a class="code" href="../../df/d7e/structmolbond.html">molbond</a> *MB,*MBTMP;
00016 <a class="code" href="../../da/d09/structangle__index.html">angle_index</a> *MANG;
00017 <a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a> *MTOR;
00018 <a class="code" href="../../d2/d4f/structmolindex.html">molindex</a> *MOLI,*MOLBNDI; <span class="comment">// MOLI for here, MOLBNDI for assigning molecules</span>
00019 <span class="keywordtype">char</span> **ATNAME,**TREECLASS,*RADTYPE,tmp[80];
00020 <span class="keywordtype">double</span> *R,*SC,*MASS; <span class="comment">// radii and screening constants for IS, atom masses</span>
00021 <a class="code" href="../../dc/d59/structfileset.html">fileset</a> F;
00022 
00023 <span class="comment">// do some initializations</span>
00024 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo20">nPRM</a>=1;
00025 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>=(<a class="code" href="../../db/d68/structparameter__set.html">parameter_set</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../db/d68/structparameter__set.html">parameter_set</a>));
00026 
00027 <span class="comment">// First, find the pointers and read them into the top structure</span>
00028 <span class="comment">// Also add them to the assembly, as needed</span>
00029 <span class="comment">// Any that are not added now can be added later -- chances are that </span>
00030 <span class="comment">//      no one had a use for them previously.  In any case, they will</span>
00031 <span class="comment">//      be present as-is in the void pointer</span>
00032 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo2">nS</a>;pa++){ <span class="comment">// get pointers first...</span>
00033         <span class="keywordflow">if</span>(strcmp(P[0].SN[pa],<span class="stringliteral">"POINTERS"</span>)==0){ 
00034                 <span class="comment">// total number of atoms</span>
00035                 sscanf(P[0].S[pa].D[0],<span class="stringliteral">"%d"</span>,&amp;P[0].NATOM); 
00036                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>; 
00037                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>&gt;0){
00038                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>*));
00039                         MOLI=(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>)); <span class="comment">// to keep up with locations per atom</span>
00040                         } 
00041                 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb]=(<a class="code" href="../../da/d81/structatom.html">atom</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>));}
00042                 <span class="comment">// number of atom types</span>
00043                 sscanf(P[0].S[pa].D[1],<span class="stringliteral">"%d"</span>,&amp;P[0].NTYPES); 
00044                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>; 
00045                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>&gt;0){
00046                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>=(<a class="code" href="../../dc/d7a/structatype.html">atype</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../dc/d7a/structatype.html">atype</a>));
00047                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>*(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>+1)/2;
00048                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>=(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>));
00049                         nICO=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>*A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>;
00050                         ICO=(<span class="keywordtype">int</span>*)calloc(nICO,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00051                         } 
00052                 <span class="comment">// Numbers of actual bonds, angles, dihedrals</span>
00053                 <span class="comment">// NOT adding these number-of distinctions to the assembly</span>
00054                 <span class="comment">// Instead, adding them all as plain bonds, etc. (see "D" description for distinction)</span>
00055                 <span class="comment">// See also NBONA, etc., below (constraints)...</span>
00056                 sscanf(P[0].S[pa].D[2],<span class="stringliteral">"%d"</span>,&amp;P[0].NBONH); <span class="comment">// number of bonds containing hydrogen</span>
00057                 sscanf(P[0].S[pa].D[3],<span class="stringliteral">"%d"</span>,&amp;P[0].MBONA); <span class="comment">// number of bonds not containing hydrogen</span>
00058                 sscanf(P[0].S[pa].D[4],<span class="stringliteral">"%d"</span>,&amp;P[0].NTHETH); <span class="comment">// number of angles containing hydrogen</span>
00059                 sscanf(P[0].S[pa].D[5],<span class="stringliteral">"%d"</span>,&amp;P[0].MTHETA); <span class="comment">// number of angles not containing hydrogen</span>
00060                 sscanf(P[0].S[pa].D[6],<span class="stringliteral">"%d"</span>,&amp;P[0].NPHIH); <span class="comment">// number of dihedrals containing hydrogen</span>
00061                 sscanf(P[0].S[pa].D[7],<span class="stringliteral">"%d"</span>,&amp;P[0].MPHIA); <span class="comment">// number of dihedrals not containing hydrogen</span>
00062                 <span class="comment">// Unused parameters and the excluded atoms list (probably not used in glycam)</span>
00063                 <span class="comment">// NOT adding these at all</span>
00064                 sscanf(P[0].S[pa].D[8],<span class="stringliteral">"%d"</span>,&amp;P[0].NHPARM); <span class="comment">// currently not used</span>
00065                 sscanf(P[0].S[pa].D[9],<span class="stringliteral">"%d"</span>,&amp;P[0].NPARM); <span class="comment">// currently not used</span>
00066                 sscanf(P[0].S[pa].D[10],<span class="stringliteral">"%d"</span>,&amp;P[0].NEXT); <span class="comment">// number of excluded atoms</span>
00067                 <span class="comment">// Number of residues</span>
00068                 sscanf(P[0].S[pa].D[11],<span class="stringliteral">"%d"</span>,&amp;P[0].NRES); 
00069                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo25">NRES</a>; 
00070                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*));} <span class="comment">// will move these later </span>
00071                 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>;pb++){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb]=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>));}
00072                 <span class="comment">// The rest of the bonds, angles and torsions (constraints)</span>
00073                 sscanf(P[0].S[pa].D[12],<span class="stringliteral">"%d"</span>,&amp;P[0].NBONA); <span class="comment">// MBONA + number of constraint bonds</span>
00074                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a> + P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo26">NBONA</a>; <span class="comment">// all the bonds</span>
00075                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>=(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>));}
00076                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>&gt;0){MB=(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>));}
00077                 sscanf(P[0].S[pa].D[13],<span class="stringliteral">"%d"</span>,&amp;P[0].NTHETA); <span class="comment">// MTHETA + number of constraint angles</span>
00078                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo27">NTHETA</a>; <span class="comment">// all the angles</span>
00079                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo17">ANG</a>=(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>));}
00080                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>&gt;0){MANG=(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>));}
00081                 sscanf(P[0].S[pa].D[14],<span class="stringliteral">"%d"</span>,&amp;P[0].NPHIA); <span class="comment">// MPHIA + number of constraint dihedrals</span>
00082                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo28">NPHIA</a>; <span class="comment">// all the torsions</span>
00083                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo19">TOR</a>=(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>));}
00084                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>&gt;0){MTOR=(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>));}
00085                 <span class="comment">// Numbers of bond, angle and torsion types</span>
00086                 sscanf(P[0].S[pa].D[15],<span class="stringliteral">"%d"</span>,&amp;P[0].NUMBND); <span class="comment">// number of unique bond types</span>
00087                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo29">NUMBND</a>; <span class="comment">// number of unique bond types</span>
00088                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto7">BT</a>=(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>));}
00089                 sscanf(P[0].S[pa].D[16],<span class="stringliteral">"%d"</span>,&amp;P[0].NUMANG); <span class="comment">// number of unique angle types</span>
00090                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo30">NUMANG</a>; <span class="comment">// number of unique angle types</span>
00091                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto13">ANT</a>=(<a class="code" href="../../dc/ddd/structangle__type.html">angle_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../dc/ddd/structangle__type.html">angle_type</a>));}
00092                 sscanf(P[0].S[pa].D[17],<span class="stringliteral">"%d"</span>,&amp;P[0].NPTRA); <span class="comment">// number of unique dihedral types</span>
00093                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo31">NPTRA</a>; <span class="comment">// number of unique dihedral types</span>
00094                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>=(<a class="code" href="../../da/d03/structtorsion__type.html">torsion_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d03/structtorsion__type.html">torsion_type</a>));}
00095                 <span class="comment">// Number of atom types in parameter file</span>
00096                 <span class="comment">// NOT adding this at all at present</span>
00097                 sscanf(P[0].S[pa].D[18],<span class="stringliteral">"%d"</span>,&amp;P[0].NATYP); <span class="comment">// number of atom types in parameter file, see SOLTY below</span>
00098                 <span class="comment">// Number of Lennard-Jones 10-12 H-Bond pair types</span>
00099                 sscanf(P[0].S[pa].D[19],<span class="stringliteral">"%d"</span>,&amp;P[0].NPHB); <span class="comment">// number of distinct 10-12 hydrogen bond pair types</span>
00100                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto8">nHBT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo33">NPHB</a>;
00101                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto8">nHBT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto9">HBT</a>=(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto8">nHBT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>));}
00102                 <span class="comment">// Perturbation information</span>
00103                 <span class="comment">// NOT adding these at all (no longer used as of AMBER 10)</span>
00104                 sscanf(P[0].S[pa].D[20],<span class="stringliteral">"%d"</span>,&amp;P[0].IFPERT); <span class="comment">// set to 1 if perturbation info is to be read in</span>
00105                 sscanf(P[0].S[pa].D[21],<span class="stringliteral">"%d"</span>,&amp;P[0].NBPER); <span class="comment">// number of bonds to be perturbed</span>
00106                 sscanf(P[0].S[pa].D[22],<span class="stringliteral">"%d"</span>,&amp;P[0].NGPER); <span class="comment">// number of angles to be perturbed</span>
00107                 sscanf(P[0].S[pa].D[23],<span class="stringliteral">"%d"</span>,&amp;P[0].NDPER); <span class="comment">// number of dihedrals to be perturbed</span>
00108                 sscanf(P[0].S[pa].D[24],<span class="stringliteral">"%d"</span>,&amp;P[0].MBPER); <span class="comment">// number of bonds with atoms completely in perturbed group</span>
00109                 sscanf(P[0].S[pa].D[25],<span class="stringliteral">"%d"</span>,&amp;P[0].MGPER); <span class="comment">// number of angles with atoms completely in perturbed group</span>
00110                 sscanf(P[0].S[pa].D[26],<span class="stringliteral">"%d"</span>,&amp;P[0].MDPER); <span class="comment">// number of dihedrals with atoms completely in perturbed groups</span>
00111                 <span class="comment">// Box information</span>
00112                 sscanf(P[0].S[pa].D[27],<span class="stringliteral">"%d"</span>,&amp;P[0].IFBOX); <span class="comment">// set to 1 if standard periodic box, 2 when truncated octahedral</span>
00113                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>==0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"none"</span>);}
00114                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>==1){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"standard periodic"</span>);}
00115                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>==2){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"truncated octahedral"</span>);}
00116                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>&gt;2){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"unknown box type"</span>);}
00117                 <span class="comment">// NOT adding these at all </span>
00118                 sscanf(P[0].S[pa].D[28],<span class="stringliteral">"%d"</span>,&amp;P[0].NMXRS); <span class="comment">// number of atoms in the largest residue</span>
00119                 sscanf(P[0].S[pa].D[29],<span class="stringliteral">"%d"</span>,&amp;P[0].IFCAP); <span class="comment">// set to 1 if the CAP option from edit was specified</span>
00120                 <span class="comment">//</span>
00121                 <span class="keywordflow">break</span>; <span class="comment">// no need to keep scanning...</span>
00122                 }
00123         }
00124 
00125 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo2">nS</a>;pa++){<span class="comment">// Loop through each of the sections</span>
00126         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a> = 1; <span class="comment">// Set is_standard to one as default</span>
00127         <span class="comment">//      check against each standard section</span>
00128         <span class="comment">//      if there is a match:</span>
00129         <span class="comment">//              set is_standard to zero</span>
00130         <span class="comment">//              record to assembly as needed</span>
00131         <span class="comment">//</span>
00132 
00133 <span class="comment">//FORMAT(20a4)  (ITITL(i), i=1,20)</span>
00134 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"TITLE"</span>)==0){ <span class="comment">// place in the Assembly description</span>
00135         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo12">ITITL</a> = pa; <span class="comment">// the title section </span>
00136         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00137         <span class="comment">// copy the title into the assembly's description</span>
00138         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo2">D</a>=(<span class="keywordtype">char</span>*)calloc(P[0].S[pa].nt*P[0].S[pa].nc+1,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00139         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){strcat(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo2">D</a>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono10">D</a>[pb]);}
00140 }
00141 <span class="comment">//FORMAT(12i6) </span>
00142 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"POINTERS"</span>)==0){ <span class="comment">// these are already added</span>
00143         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo13">POINTERS</a>=pa; <span class="comment">// pointer to the section containing the original char-strings</span>
00144         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00145 }
00146 <span class="comment">// FORMAT(20a4)  (IGRAPH(i), i=1,NATOM)</span>
00147 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ATOM_NAME"</span>)==0){ <span class="comment">// these eventually go into the molecules/residues/etc</span>
00148         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo44">IGRAPH</a>=pa; <span class="comment">// IGRAPH : the user atoms names </span>
00149         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00150         <span class="comment">// for now, add these to the straight list of Assembly atoms</span>
00151 <span class="comment">//printf("A.na is %d\n",A.na);</span>
00152         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in ATOM_NAME in parse_amber_prmtop"</span>);}
00153         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00154                 <span class="comment">//A.a[pb][0].N=(char*)calloc((P[0].S[pa].nc+1),sizeof(char));</span>
00155 <span class="comment">//printf("P[0].S[%d].D[%d] is ",pa,pb);</span>
00156 <span class="comment">//printf("&gt;&gt;&gt;%s&lt;&lt;&lt;\n",P[0].S[pa].D[pb]);</span>
00157                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,tmp);
00158                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>=(<span class="keywordtype">char</span>*)calloc((strlen(tmp)+1),<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00159                 strcpy(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>,tmp);
00160                 <span class="comment">//sscanf(P[0].S[pa].D[pb],"%s",A.a[pb][0].N);</span>
00161 <span class="comment">//printf("P[0].S[pa].D[pb] is &gt;&gt;&gt;%s&lt;&lt;&lt; and A.a[pb][0].N is &gt;&gt;&gt;%s&lt;&lt;&lt; (strlen %d)\t",P[0].S[pa].D[pb],A.a[pb][0].N,strlen(A.a[pb][0].N));</span>
00162                 <span class="comment">//A.a[pb][0].N=(char*)realloc(A.a[pb][0].N,strlen(A.a[pb][0].N+1));</span>
00163 <span class="comment">//printf("P[0].S[pa].D[pb] is &gt;&gt;&gt;%s&lt;&lt;&lt; and A.a[pb][0].N is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",P[0].S[pa].D[pb],A.a[pb][0].N);</span>
00164 
00165                 }
00166 }
00167 <span class="comment">// FORMAT(5E16.8)  (CHRG(i), i=1,NATOM)</span>
00168 <span class="comment">// (Divide by 18.2223 to convert to charge in units of the electron charge) </span>
00169 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"CHARGE"</span>)==0){ <span class="comment">// these go with each atom</span>
00170         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo45">CHRG</a>   =pa; <span class="comment">// CHRG   : the atom charges.  </span>
00171         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00172         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in CHARGE in parse_amber_prmtop"</span>);}
00173         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00174                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo16">nch</a>=1;
00175                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo17">ch</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00176                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo17">ch</a>[0]);
00177                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo17">ch</a>[0]/=18.2223;
00178                 }
00179 }
00180 <span class="comment">// FORMAT(5E16.8)  (AMASS(i), i=1,NATOM)</span>
00181 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"MASS"</span>)==0){ <span class="comment">// with each atom</span>
00182         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo46">AMASS</a>  =pa; <span class="comment">// AMASS  : the atom masses </span>
00183         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00184         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in AMASS in parse_amber_prmtop"</span>);}
00185         MASS=(<span class="keywordtype">double</span>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00186         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;MASS[pb]);}
00187         <span class="comment">//for(pb=0;pb&lt;A.na;pb++){sscanf(P[0].S[pa].D[pb],"%lf",&amp;A.a[pb][0].m);}</span>
00188 }
00189 <span class="comment">// FORMAT(12I6)  (IAC(i), i=1,NATOM)</span>
00190 <span class="comment">// START HERE -- is this really just an atom type index?  One hopes...</span>
00191 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ATOM_TYPE_INDEX"</span>)==0){ <span class="comment">// into the atype structure</span>
00192         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo47">IAC</a>    =pa; <span class="comment">// IAC    : index for the atom types involved in Lennard Jones (6-12) </span>
00193         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00194         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in ATOM_TYPE_INDEX in parse_amber_prmtop"</span>);}
00195         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00196                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>);
00197                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>--;
00198                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>&lt;0){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.a[pb][0].t&lt;0 in parse_amber_prmtop"</span>);}
00199                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pa][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>&gt;=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.a[pa][0].t&gt;=P[0].NTYPES in parse_amber_prmtop"</span>);}
00200                 }
00201 }
00202                 <span class="comment">// interactions.  See ICO below.  </span>
00203 <span class="comment">// FORMAT(12I6)  (NUMEX(i), i=1,NATOM)</span>
00204 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"NUMBER_EXCLUDED_ATOMS"</span>)==0){ <span class="comment">// unused for now (20080612)</span>
00205         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo48">NUMEX</a>  =pa; <span class="comment">// NUMEX  : total number of excluded atoms for atom "i".  See</span>
00206         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00207 }
00208                 <span class="comment">// NATEX below.  </span>
00209 <span class="comment">// FORMAT(12I6)  (ICO(i), i=1,NTYPES*NTYPES)</span>
00210 <span class="comment">// START HERE -- figure out how to put this is (efficiently...)</span>
00211 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"NONBONDED_PARM_INDEX"</span>)==0){ <span class="comment">// </span>
00212         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo49">ICO</a>    =pa; <span class="comment">// ICO    : provides the index to the nonbon parameter</span>
00213         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00214         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=nICO){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=nICO in parse_amber_prmtop."</span>);}
00215         <span class="keywordflow">for</span>(pb=0;pb&lt;nICO;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;ICO[pb]);}
00216                 <span class="comment">// arrays CN1, CN2 and ASOL, BSOL.  All possible 6-12</span>
00217                 <span class="comment">// or 10-12 atoms type interactions are represented.</span>
00218                 <span class="comment">// NOTE: A particular atom type can have either a 10-12</span>
00219                 <span class="comment">// or a 6-12 interaction, but not both.  The index is</span>
00220                 <span class="comment">// calculated as follows:</span>
00221                 <span class="comment">// index = ICO(NTYPES*(IAC(i)-1)+IAC(j))</span>
00222                 <span class="comment">// If index is positive, this is an index into the</span>
00223                 <span class="comment">// 6-12 parameter arrays (CN1 and CN2) otherwise it</span>
00224                 <span class="comment">// is an index into the 10-12 parameter arrays (ASOL and BSOL).  </span>
00225 }
00226 <span class="comment">// FORMAT(20A4)  (LABRES(i), i=1,NRES)</span>
00227 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RESIDUE_LABEL"</span>)==0){ <span class="comment">// names of residues</span>
00228         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo50">LABRES</a> =pa; <span class="comment">// LABRES : the residue labels </span>
00229         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00230         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.nr in RESIDUE_LABEL in parse_amber_prmtop"</span>);}
00231         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>;pb++){
00232                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>=(<span class="keywordtype">char</span>*)calloc((P[0].S[pa].nc+1),<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00233                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>);
00234                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>=(<span class="keywordtype">char</span>*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>,strlen(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>+1));
00235                 }
00236 }
00237 <span class="comment">// FORMAT(10a8)</span>
00238 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RESIDUE_ID"</span>)==0){<span class="comment">// ?? Presumably residue numbers, will store there</span>
00239         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo51">IRES</a> =pa; <span class="comment">// START HERE -- this is probably the wrong name!!!!!</span>
00240         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00241         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.nr in RESIDUE_ID in parse_amber_prmtop"</span>);}
00242         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo0">n</a>);}
00243 }
00244 <span class="comment">// FORMAT(12I6)  (IPRES(i), i=1,NRES)</span>
00245 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RESIDUE_POINTER"</span>)==0){ <span class="comment">// for adding atoms to residues</span>
00246         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo52">IPRES</a>  =pa; <span class="comment">// IPRES  : atoms in each residue are listed for atom "i" in</span>
00247         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00248         pc=0;
00249         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.nr in RESIDUE_POINTER in parse_amber_prmtop"</span>);}
00250 <span class="comment">//printf("A.nr is %d\n",A.nr);</span>
00251         <span class="keywordflow">for</span>(pb=0;pb&lt;(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>-1);pb++){
00252 <span class="comment">//printf("pb is %d\n",pb);</span>
00253                 sscanf(P[0].S[pa].D[pb+1],<span class="stringliteral">"%d"</span>,&amp;NextRes);
00254 <span class="comment">//printf("NextRes is %d\n",NextRes);</span>
00255                 NextRes-=1;
00256                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>=NextRes-pc;
00257 <span class="comment">//printf("A.r[pb][0].na is %d\n",A.r[pb][0].na);</span>
00258                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>));
00259                 pd=0;
00260                 <span class="keywordflow">for</span>(pc=pc;pc&lt;NextRes;pc++){
00261 <span class="comment">//printf("pc is %d\n",pc);</span>
00262                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0]; <span class="comment">// copy atom into residue</span>
00263                         <span class="comment">//A.r[pb][0].a[NextRes-pc]=A.a[pc][0]; // copy atom into residue</span>
00264                         <span class="comment">//free(A.a[pc]); // free that memory</span>
00265                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc]=&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]; <span class="comment">// set atom pointer to new location</span>
00266                         <span class="comment">//A.a[pc]=&amp;A.r[pb][0].a[NextRes-pc]; // set atom pointer to new location</span>
00267                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>=pc+1; <span class="comment">// set the amber original number</span>
00268                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pc; <span class="comment">// set absolute atom number in array terms</span>
00269                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know this yet</span>
00270                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=pb; <span class="comment">// check this later</span>
00271                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pd; <span class="comment">// check this later</span>
00272                         <span class="comment">//MOLI[pc].a=NextRes-pc; // check this later</span>
00273                         pd++;
00274                         }
00275                 }
00276 <span class="comment">//printf("pb is %d\n",pb);</span>
00277                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>-pc;
00278 <span class="comment">//printf("A.r[pb][0].na is %d\n",A.r[pb][0].na);</span>
00279                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>));
00280                 pd=0;
00281                 <span class="keywordflow">for</span>(pc=pc;pc&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>;pc++){
00282 <span class="comment">//printf("pc is %d\t",pc);</span>
00283                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0]; <span class="comment">// copy atom into residue</span>
00284 <span class="comment">//printf("the name of atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.a[pc][0].N);</span>
00285 <span class="comment">//printf("\tthe charge of atom pc is &gt;&gt;&gt;%f&lt;&lt;&lt;\n",A.a[pc][0].ch[0]);</span>
00286 <span class="comment">//printf("the name of new atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.r[pb][0].a[pd].N);</span>
00287 <span class="comment">//printf("\tthe charge of new atom pc is &gt;&gt;&gt;%f&lt;&lt;&lt;\n",A.r[pb][0].a[pd].ch[0]);</span>
00288                         <span class="comment">//A.r[pb][0].a[NextRes-pc]=A.a[pc][0]; // copy atom into residue</span>
00289                         <span class="comment">//free(A.a[pc]); // free that memory</span>
00290 <span class="comment">//printf("\t***the name of new atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.r[pb][0].a[pd].N);</span>
00291 <span class="comment">//printf("\t***the charge of new atom pc is &gt;&gt;&gt;%f&lt;&lt;&lt;\n",A.r[pb][0].a[pd].ch[0]);</span>
00292 <span class="comment">//printf("xxxx the name of atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.a[pc][0].N);</span>
00293                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc]=&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]; <span class="comment">// set atom pointer to new location</span>
00294                         <span class="comment">//A.a[pc]=&amp;A.r[pb][0].a[NextRes-pc]; // set atom pointer to new location</span>
00295                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>=pc+1; <span class="comment">// set the amber original number</span>
00296                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pc; <span class="comment">// set absolute atom number in array terms</span>
00297                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know this yet</span>
00298                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=pb; <span class="comment">// check this later</span>
00299                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pd; <span class="comment">// check this later</span>
00300                         <span class="comment">//MOLI[pc].a=NextRes-pc; // check this later</span>
00301                         pd++;
00302                         }
00303 
00304         
00305 }
00306                 <span class="comment">// IPRES(i) to IPRES(i+1)-1 </span>
00307 <span class="comment">// FORMAT(5E16.8)  (RK(i), i=1,NUMBND)</span>
00308 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BOND_FORCE_CONSTANT"</span>)==0){ <span class="comment">// </span>
00309         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo53">RK</a>     =pa; <span class="comment">// RK     : force constant for the bonds of each type, kcal/mol </span>
00310         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00311 <span class="comment">//printf("pa is %d; this is BOND_FORCE_CONSTANT\n",pa);</span>
00312 <span class="comment">//printf("the number of bond types is %d\n",A.PRM[0].nBT);</span>
00313         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nBT in BOND_FORCE_CONSTANT in parse_amber_prmtop"</span>);}
00314         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>;pb++){
00315 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,pb,P[0].S[pa].D[pb]);</span>
00316                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto7">BT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo3">k</a>);
00317                 }
00318 }
00319 <span class="comment">// FORMAT(5E16.8)  (REQ(i), i=1,NUMBND)</span>
00320 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BOND_EQUIL_VALUE"</span>)==0){
00321         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo54">REQ</a>    =pa; <span class="comment">// REQ    : the equilibrium bond length for the bonds of each type, angstroms </span>
00322         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00323         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nBT in BOND_EQUIL_VALUE in parse_amber_prmtop"</span>);}
00324         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto7">BT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo4">l</a>);}
00325 }
00326 <span class="comment">// FORMAT(5E16.8)  (TK(i), i=1,NUMANG)</span>
00327 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLE_FORCE_CONSTANT"</span>)==0){
00328         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo55">TK</a>     =pa; <span class="comment">// TK     : force constant for the angles of each type, kcal/mol A**2 </span>
00329         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00330         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nANT in ANGLE_FORCE_CONSTANT in parse_amber_prmtop"</span>);}
00331         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto13">ANT</a>[pb].<a class="code" href="../../dc/ddd/structangle__type.html#angle__typeo2">k</a>);}
00332 }
00333 <span class="comment">// FORMAT(5E16.8)  (TEQ(i), i=1,NUMANG)</span>
00334 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLE_EQUIL_VALUE"</span>)==0){
00335         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo56">TEQ</a>    =pa; <span class="comment">// TEQ    : the equilibrium angle for the angles of each type, radians </span>
00336         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00337         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nANT in ANGLE_EQUIL_VALUE in parse_amber_prmtop"</span>);}
00338         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto13">ANT</a>[pb].<a class="code" href="../../dc/ddd/structangle__type.html#angle__typeo3">l</a>);}
00339 }
00340 <span class="comment">// FORMAT(5E16.8)  (PK(i), i=1,NPTRA)</span>
00341 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRAL_FORCE_CONSTANT"</span>)==0){
00342         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo57">PK</a>     =pa; <span class="comment">// PK     : force constant for the dihedrals of each type, kcal/mol </span>
00343         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00344         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nTRT in DIHEDRAL_FORCE_CONSTANT in parse_amber_prmtop"</span>);}
00345         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>;pb++){
00346                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>&gt;1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.PRM[0].TRT[pb].n&gt;1 in parse_amber_prmtop!"</span>);}
00347                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>=1;
00348                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo3">k</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00349                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo3">k</a>[0]);
00350                 }
00351 }
00352 <span class="comment">// FORMAT(5E16.8)  (PN(i), i=1,NPTRA)</span>
00353 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRAL_PERIODICITY"</span>)==0){
00354         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo58">PN</a>     =pa; <span class="comment">// PN     : periodicity of the dihedral of a given type </span>
00355         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00356         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nTRT in DIHEDRAL_PERIODICITY in parse_amber_prmtop"</span>);}
00357         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>;pb++){
00358                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>&gt;1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.PRM[0].TRT[pb].n&gt;1 in parse_amber_prmtop!"</span>);}
00359                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>=1;
00360                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo4">N</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00361                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo4">N</a>[0]);
00362                 }
00363 }
00364 <span class="comment">// FORMAT(5E16.8)  (PHASE(i), i=1,NPTRA)</span>
00365 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRAL_PHASE"</span>)==0){
00366         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo59">PHASE</a>  =pa; <span class="comment">// PHASE  : phase of the dihedral of a given type, radians </span>
00367         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00368         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nTRT in DIHEDRAL_PHASE in parse_amber_prmtop"</span>);}
00369         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>;pb++){
00370                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>&gt;1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.PRM[0].TRT[pb].n&gt;1 in parse_amber_prmtop!"</span>);}
00371                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>=1;
00372                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo5">P</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00373                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo5">P</a>[0]);
00374                 }
00375 }
00376 <span class="comment">// FORMAT(5E16.8)  (SOLTY(i), i=1,NATYP)</span>
00377 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"SOLTY"</span>)==0){ <span class="comment">// not much to do here at the moment</span>
00378         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo60">SOLTY</a>  =pa; <span class="comment">// SOLTY  : currently unused (reserved for future use) </span>
00379         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00380 }
00381 <span class="comment">// FORMAT(5E16.8)  (CN1(i), i=1,NTYPES*(NTYPES+1)/2)</span>
00382 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LENNARD_JONES_ACOEF"</span>)==0){
00383         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo61">CN1</a>    =pa; <span class="comment">// CN1    : Lennard Jones r**12 terms for all possible atom type</span>
00384         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00385         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>){
00386                 fprintf(stdout,<span class="stringliteral">"P[0].S[pa].nt (%d) !=A.PRM[0].nNBT (%d) in LENNARD_JONES_ACOEF in parse_amber_prmtop\n"</span>,P[0].S[pa].nt,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>);
00387                 <span class="comment">//mywhine("P[0].S[pa].nt!=A.PRM[0].nNBT in LENNARD_JONES_ACOEF in parse_amber_prmtop");</span>
00388                 } 
00389         <span class="comment">// record the LJ parameters to the bond type info</span>
00390         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>;pb++){ sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo11">LJ12_612</a>); }
00391                 <span class="comment">// interactions, indexed by ICO and IAC; for atom i and j</span>
00392                 <span class="comment">// where i &lt; j, the index into this array is as follows</span>
00393                 <span class="comment">// (assuming the value of ICO(index) is positive):</span>
00394                 <span class="comment">// CN1(ICO(NTYPES*(IAC(i)-1)+IAC(j))).  </span>
00395 }
00396 <span class="comment">// FORMAT(5E16.8)  (CN2(i), i=1,NTYPES*(NTYPES+1)/2)</span>
00397 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LENNARD_JONES_BCOEF"</span>)==0){
00398         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo62">CN2</a>    =pa; <span class="comment">// CN2    : Lennard Jones r**6 terms for all possible atom type</span>
00399         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00400         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>){
00401                 fprintf(stdout,<span class="stringliteral">"P[0].S[pa].nt (%d) !=A.PRM[0].nNBT (%d) in LENNARD_JONES_BCOEF in parse_amber_prmtop\n"</span>,P[0].S[pa].nt,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>);
00402                 <span class="comment">//mywhine("P[0].S[pa].nt!=A.PRM[0].nNBT in LENNARD_JONES_BCOEF in parse_amber_prmtop");</span>
00403                 }
00404         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo10">LJ6_612</a>);}
00405                 <span class="comment">// interactions.  Indexed like CN1 above.  </span>
00406 }
00407 <span class="comment">/* NOTE: the atom numbers in the following arrays that describe bonds, </span>
00408 <span class="comment">        angles, and dihedrals are coordinate array indexes for runtime speed. </span>
00409 <span class="comment">        The true atom number equals the absolute value of the number divided by </span>
00410 <span class="comment">        three, plus one. In the case of the dihedrals, if the fourth atom is negative, </span>
00411 <span class="comment">        this implies that the dihedral is an improper. If the third atom is negative, </span>
00412 <span class="comment">        this implies that the end group interations are to be ignored. End group </span>
00413 <span class="comment">        interactions are ignored, for example, in dihedrals of various ring systems </span>
00414 <span class="comment">        (to prevent double counting of 1-4 interactions) and in multiterm dihedrals.  */</span>
00415 <span class="comment">// FORMAT(12I6)  (IBH(i),JBH(i),ICBH(i), i=1,NBONH)</span>
00416 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BONDS_INC_HYDROGEN"</span>)==0){
00417         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo63">IBH</a>    =pa; <span class="comment">// IBH    : atom involved in bond "i", bond contains hydrogen</span>
00418         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo64">JBH</a>    =pa; <span class="comment">// JBH    : atom involved in bond "i", bond contains hydrogen</span>
00419         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo65">ICBH</a>   =pa; <span class="comment">// ICBH   : index into parameter arrays RK and REQ </span>
00420         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00421         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=3*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].NBONH in BONDS_INC_HYDROGEN in parse_amber_prmtop"</span>);}
00422         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>;pb++){
00423                 <span class="comment">// read in the values from the section structure</span>
00424                 sscanf(P[0].S[pa].D[3*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00425                 sscanf(P[0].S[pa].D[3*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00426                 sscanf(P[0].S[pa].D[3*pb+2],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00427 <span class="comment">//printf("pA1 is %d ; pA2 is %d ; pI1 is %d \n",pA1,pA2,pI1);</span>
00428                 <span class="comment">// find the actual atom numbers</span>
00429                 pA1/=3;  <span class="comment">// CAREFUL !! these can be negative</span>
00430                 pA2/=3; 
00431                 <span class="comment">// set the bond info for these two atoms</span>
00432                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00433                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00434                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00435                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00436                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo5">D</a>=strdup(<span class="stringliteral">"BONDS_INC_HYDROGEN"</span>);
00437                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00438                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00439                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// </span>
00440                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA1; <span class="comment">// </span>
00441                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00442                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00443                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA2; 
00444                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00445 <span class="comment">//printf("MB[pb].s.i is  %d ; MB[pb].t.i is %d ;  MB[%d].i is %d \n",MB[pb].s.i,MB[pb].t.i,pb,MB[pb].i);</span>
00446                 }
00447 }
00448 <span class="comment">// FORMAT(12I6)  (IB(i),JB(i),ICB(i), i=1,NBONA)</span>
00449 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BONDS_WITHOUT_HYDROGEN"</span>)==0){
00450         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo66">IB</a>     =pa; <span class="comment">// IB     : atom involved in bond "i", bond does not contain hydrogen</span>
00451         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo67">JB</a>     =pa; <span class="comment">// JB     : atom involved in bond "i", bond does not contain hydrogen</span>
00452         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo68">ICB</a>    =pa; <span class="comment">// ICB    : index into parameter arrays RK and REQ </span>
00453         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00454 <span class="comment">//printf("NBONH is %d ; MBONA is %d ; (sum : %d) and nb is A.nb=%d \n", P[0].NBONH,P[0].MBONA,P[0].MBONA+P[0].NBONH,A.nb);</span>
00455         <span class="comment">//for(pb=P[0].NBONH;pb&lt;(P[0].NBONH+P[0].MBONA);pb++) // save this line for use later...</span>
00456         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=3*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo17">MBONA</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].MBONA in BONDS_WITHOUT_HYDROGEN in parse_amber_prmtop"</span>);}
00457         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo17">MBONA</a>;pb++){ <span class="comment">// save this line for use later...</span>
00458 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,3*pb,P[0].S[pa].D[3*pb]);</span>
00459 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,3*pb+1,P[0].S[pa].D[3*pb+1]);</span>
00460 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,3*pb+2,P[0].S[pa].D[3*pb+2]);</span>
00461                 <span class="comment">// read in the values from the section structure</span>
00462                 sscanf(P[0].S[pa].D[3*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00463                 sscanf(P[0].S[pa].D[3*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00464                 sscanf(P[0].S[pa].D[3*pb+2],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00465 <span class="comment">//printf("(non-H) pA1 is %d ; pA2 is %d ; pI1 is %d \n",pA1,pA2,pI1);</span>
00466                 <span class="comment">// find the actual atom numbers</span>
00467                 <span class="keywordflow">if</span>(pA1&lt;0) pA1*=-1;
00468                 <span class="keywordflow">if</span>(pA2&lt;0) pA2*=-1;
00469                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00470                 pA2/=3; 
00471                 <span class="comment">// set the bond info for these two atoms</span>
00472                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00473                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00474                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00475                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00476                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo5">D</a>=strdup(<span class="stringliteral">"BONDS_WITHOUT_HYDROGEN"</span>);
00477                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00478                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00479                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// the best atom number we have at the moment</span>
00480                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA1; <span class="comment">// for assigning molecules based on bonds, later</span>
00481                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00482                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00483                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00484                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA2; 
00485 <span class="comment">//printf("(non-H) MB[pb].s.i is  %d ; MB[pb].t.i is %d ;  MB[%d].i is %d \n",MB[pb+P[0].NBONH].s.i,MB[pb+P[0].NBONH].t.i,pb+P[0].NBONH,MB[pb+P[0].NBONH].i);</span>
00486                 }
00487 }
00488 <span class="comment">// FORMAT(12I6)  (ITH(i),JTH(i),KTH(i),ICTH(i), i=1,NTHETH)</span>
00489 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLES_INC_HYDROGEN"</span>)==0){
00490         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo69">ITH</a>    =pa; <span class="comment">// ITH    : atom involved in angle "i", angle contains hydrogen</span>
00491         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo70">JTH</a>    =pa; <span class="comment">// JTH    : atom involved in angle "i", angle contains hydrogen</span>
00492         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo71">KTH</a>    =pa; <span class="comment">// KTH    : atom involved in angle "i", angle contains hydrogen</span>
00493         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo72">ICTH</a>   =pa; <span class="comment">// ICTH   : index into parameter arrays TK and TEQ for angle</span>
00494         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00495         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=4*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].NTHETH in ANGLES_INC_HYDROGEN in parse_amber_prmtop"</span>);}
00496         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>;pb++){ <span class="comment">// angles with hydrogen</span>
00497                 <span class="comment">// read in the values from the section structure</span>
00498                 sscanf(P[0].S[pa].D[4*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00499                 sscanf(P[0].S[pa].D[4*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00500                 sscanf(P[0].S[pa].D[4*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00501                 sscanf(P[0].S[pa].D[4*pb+3],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00502                 <span class="comment">// find the actual atom numbers</span>
00503                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00504                 pA2/=3; 
00505                 pA3/=3; 
00506                 <span class="comment">// set the bond info for these two atoms</span>
00507                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00508                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00509                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00510                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo6">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00511                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo5">D</a>=strdup(<span class="stringliteral">"ANGLES_INC_HYDROGEN"</span>);
00512                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00513                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00514                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are already read in</span>
00515                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00516                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1;
00517                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00518                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00519                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00520                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00521                 }
00522 }
00523                 <span class="comment">// ITH(i)-JTH(i)-KTH(i) </span>
00524 <span class="comment">// FORMAT(12I6)  (IT(i),JT(i),KT(i),ICT(i), i=1,NTHETA)</span>
00525 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLES_WITHOUT_HYDROGEN"</span>)==0){
00526         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo73">IT</a>     =pa; <span class="comment">// IT     : atom involved in angle "i", angle does not contain hydrogen</span>
00527         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo74">JT</a>     =pa; <span class="comment">// JT     : atom involved in angle "i", angle does not contain hydrogen</span>
00528         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo75">KT</a>     =pa; <span class="comment">// KT     : atom involved in angle "i", angle does not contain hydrogen</span>
00529         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo76">ICT</a>    =pa; <span class="comment">// ICT    : index into parameter arrays TK and TEQ for angle</span>
00530         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00531         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=4*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo19">MTHETA</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].MTHETA in ANGLES_WITHOUT_HYDROGEN in parse_amber_prmtop"</span>);}
00532         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo19">MTHETA</a>;pb++){ <span class="comment">// angles without hydrogen</span>
00533                 <span class="comment">// read in the values from the section structure</span>
00534                 sscanf(P[0].S[pa].D[4*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00535                 sscanf(P[0].S[pa].D[4*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00536                 sscanf(P[0].S[pa].D[4*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00537                 sscanf(P[0].S[pa].D[4*pb+3],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00538                 <span class="comment">// find the actual atom numbers</span>
00539                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00540                 pA2/=3; 
00541                 pA3/=3; 
00542                 <span class="comment">// set the bond info for these two atoms</span>
00543                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00544                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00545                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00546                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo6">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00547                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo5">D</a>=strdup(<span class="stringliteral">"ANGLES_WITHOUT_HYDROGEN"</span>);
00548                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00549                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00550                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are read in already</span>
00551                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00552                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00553                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00554                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00555                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00556                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00557                 }
00558 }
00559                 <span class="comment">// IT(i)-JT(i)-KT(i) </span>
00560 <span class="comment">// FORMAT(12I6)  (IPH(i),JPH(i),KPH(i),LPH(i),ICPH(i), i=1,NPHIH)</span>
00561 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRALS_INC_HYDROGEN"</span>)==0){
00562         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo77">IPH</a>    =pa; <span class="comment">// IPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00563         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo78">JPH</a>    =pa; <span class="comment">// JPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00564         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo79">KPH</a>    =pa; <span class="comment">// KPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00565         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo80">LPH</a>    =pa; <span class="comment">// LPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00566         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo81">ICPH</a>   =pa; <span class="comment">// ICPH   : index into parameter arrays PK, PN, and PHASE for</span>
00567         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00568         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=5*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].NPHIH in DIHEDRALS_INC_HYDROGEN in parse_amber_prmtop"</span>);}
00569         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>;pb++){ <span class="comment">// dihedrals with hydrogen</span>
00570                 <span class="comment">// read in the values from the section structure</span>
00571                 sscanf(P[0].S[pa].D[5*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00572                 sscanf(P[0].S[pa].D[5*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00573                 sscanf(P[0].S[pa].D[5*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00574                 sscanf(P[0].S[pa].D[5*pb+3],<span class="stringliteral">"%d"</span>,&amp;pA3);
00575                 sscanf(P[0].S[pa].D[5*pb+4],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00576                 <span class="comment">// find the actual atom numbers</span>
00577                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00578                 pA2/=3; 
00579                 pA3/=3; 
00580                 pA4/=3; 
00581                 <span class="comment">// set the bond info for these two atoms</span>
00582                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00583                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00584                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00585                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo7">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00586                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo6">D</a>=strdup(<span class="stringliteral">"DIHEDRALS_INC_HYDROGEN"</span>);
00587                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00588                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00589                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are read in already</span>
00590                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00591                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00592                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00593                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00594                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00595                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00596                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00597                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00598                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA4; 
00599                 }
00600 }
00601                 <span class="comment">// dihedral IPH(i)-JPH(i)-KPH(i)-LPH(i) </span>
00602 <span class="comment">// FORMAT(12I6)  (IP(i),JP(i),KP(i),LP(i),ICP(i), i=1,NPHIA)</span>
00603 
00604 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRALS_WITHOUT_HYDROGEN"</span>)==0){
00605         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo82">IP</a>     =pa; <span class="comment">// IP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00606         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo83">JP</a>     =pa; <span class="comment">// JP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00607         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo84">KP</a>     =pa; <span class="comment">// KP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00608         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo85">LP</a>     =pa; <span class="comment">// LP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00609         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo86">ICP</a>    =pa; <span class="comment">// ICP    : index into parameter arrays PK, PN, and PHASE for</span>
00610         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00611         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=5*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo21">MPHIA</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].MPHIA in DIHEDRALS_WITHOUT_HYDROGEN in parse_amber_prmtop"</span>);}
00612         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo21">MPHIA</a>;pb++){ <span class="comment">// dihedrals with hydrogen</span>
00613                 <span class="comment">// read in the values from the section structure</span>
00614                 sscanf(P[0].S[pa].D[5*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00615                 sscanf(P[0].S[pa].D[5*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00616                 sscanf(P[0].S[pa].D[5*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00617                 sscanf(P[0].S[pa].D[5*pb+3],<span class="stringliteral">"%d"</span>,&amp;pA3);
00618                 sscanf(P[0].S[pa].D[5*pb+4],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00619                 <span class="comment">// find the actual atom numbers</span>
00620                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00621                 pA2/=3; 
00622                 pA3/=3; 
00623                 pA4/=3; 
00624                 <span class="comment">// set the bond info for these two atoms</span>
00625                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00626                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00627                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00628                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo7">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00629                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo6">D</a>=strdup(<span class="stringliteral">"DIHEDRALS_INC_HYDROGEN"</span>);
00630                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00631                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00632                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are read in already</span>
00633                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00634                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00635                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00636                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00637                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00638                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00639                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00640                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00641                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA4; 
00642                 }
00643 }
00644 
00645                 <span class="comment">// dihedral IPH(i)-JPH(i)-KPH(i)-LPH(i).  Note, if the</span>
00646                 <span class="comment">// periodicity is negative, this implies the following entry</span>
00647                 <span class="comment">// in the PK, PN, and PHASE arrays is another term in a</span>
00648                 <span class="comment">// multitermed dihedral.  </span>
00649 <span class="comment">// FORMAT(12I6)  (NATEX(i), i=1,NEXT)</span>
00650 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"EXCLUDED_ATOMS_LIST"</span>)==0){
00651         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo87">NATEX</a>  =pa; <span class="comment">// NATEX  : the excluded atom list.  To get the excluded list for atom </span>
00652         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00653 }
00654                 <span class="comment">// "i" you need to traverse the NUMEX list, adding up all</span>
00655                 <span class="comment">// the previous NUMEX values, since NUMEX(i) holds the number</span>
00656                 <span class="comment">// of excluded atoms for atom "i", not the index into the </span>
00657                 <span class="comment">// NATEX list.  Let IEXCL = SUM(NUMEX(j), j=1,i-1), then</span>
00658                 <span class="comment">// excluded atoms are NATEX(IEXCL) to NATEX(IEXCL+NUMEX(i)).  </span>
00659 <span class="comment">// FORMAT(5E16.8)  (ASOL(i), i=1,NPHB)</span>
00660 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"HBOND_ACOEF"</span>)==0){
00661         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo88">ASOL</a>   =pa; <span class="comment">// ASOL   : the value for the r**12 term for hydrogen bonds of all</span>
00662         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00663 <span class="comment">//printf("A.PRM[0].nNBT is %d\n",A.PRM[0].nNBT);</span>
00664         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo33">NPHB</a>&gt;0){
00665         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>&gt;0){
00666         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo13">LJ12_1012</a>);}
00667         <span class="comment">//for(pb=0;pb&lt;A.PRM[0].nNBT;pb++){sscanf(P[0].S[pa].D[pb],"%lf",&amp;A.PRM[0].NBT[pb].LJ12_1012);}</span>
00668                 }
00669                 }
00670 }
00671                 <span class="comment">// possible types.  Index into these arrays is equivalent</span>
00672                 <span class="comment">// to the CN1 and CN2 arrays, however the index is negative.</span>
00673                 <span class="comment">// For example, for atoms i and j, with i &lt; j, the index is</span>
00674                 <span class="comment">// ICO(NTYPES*(IAC(i)-1+IAC(j)).  </span>
00675 <span class="comment">// FORMAT(5E16.8)  (BSOL(i), i=1,NPHB)</span>
00676 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"HBOND_BCOEF"</span>)==0){
00677         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo89">BSOL</a>   =pa; <span class="comment">// BSOL   : the value for the r**10 term for hydrogen bonds of all</span>
00678         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00679         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo33">NPHB</a>&gt;0){
00680         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>&gt;0){
00681                 <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo12">LJ10_1012</a>);}
00682                 <span class="comment">//for(pb=0;pb&lt;A.PRM[0].nNBT;pb++){sscanf(P[0].S[pa].D[pb],"%lf",&amp;A.PRM[0].NBT[pb].LJ10_1012);}</span>
00683                 }
00684                 }
00685 }
00686                 <span class="comment">// possible types.  Indexed like ASOL.  </span>
00687 <span class="comment">// FORMAT(5E16.8)  (HBCUT(i), i=1,NPHB)</span>
00688 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"HBCUT"</span>)==0){
00689         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo90">HBCUT</a>  =pa; <span class="comment">// HBCUT  : no longer in use </span>
00690         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00691 }
00692 <span class="comment">// FORMAT(20A4)  (ISYMBL(i), i=1,NATOM)</span>
00693 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"AMBER_ATOM_TYPE"</span>)==0){
00694         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo91">ISYMBL</a> =pa; <span class="comment">// ISYMBL : the AMBER atom types for each atom </span>
00695         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00696         <span class="comment">// Can't assume we've already read in the type numbers...</span>
00697         <span class="comment">// read one per each atom, just like it is in the file</span>
00698         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in AMBER_ATOM_TYPE in parse_amber_prmtop"</span>);}
00699         ATNAME=(<span class="keywordtype">char</span>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00700         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00701                 ATNAME[pb]=(<span class="keywordtype">char</span>*)calloc(P[0].S[pa].nc+1,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00702                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,ATNAME[pb]);
00703                 }
00704 }
00705 <span class="comment">// FORMAT(20A4)  (ITREE(i), i=1,NATOM)</span>
00706 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"TREE_CHAIN_CLASSIFICATION"</span>)==0){
00707         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo92">ITREE</a>  =pa; <span class="comment">// ITREE  : the list of tree joining information, classified into five</span>
00708         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00709         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in TREE_CHAIN_CLASSIFICATION in parse_amber_prmtop"</span>);}
00710         TREECLASS=(<span class="keywordtype">char</span>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00711         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00712                 TREECLASS[pb]=(<span class="keywordtype">char</span>*)calloc(P[0].S[pa].nc+1,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00713                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,TREECLASS[pb]);
00714                 }
00715 }
00716                 <span class="comment">// types.  M -- main chain, S -- side chain, B -- branch point, </span>
00717                 <span class="comment">// 3 -- branch into three chains, E -- end of the chain </span>
00718 <span class="comment">// FORMAT(12I6)  (JOIN(i), i=1,NATOM)</span>
00719 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"JOIN_ARRAY"</span>)==0){
00720         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo93">JOIN</a>   =pa; <span class="comment">// JOIN   : tree joining information, potentially used in ancient</span>
00721                 <span class="comment">// analysis programs.  Currently unused in sander or gibbs.  </span>
00722         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00723 }
00724 <span class="comment">// FORMAT(12I6)  (IROTAT(i), i = 1, NATOM)</span>
00725 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"IROTAT"</span>)==0){
00726         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo94">IROTAT</a> =pa; <span class="comment">// IROTAT : apparently the last atom that would move if atom i was</span>
00727                 <span class="comment">// rotated, however the meaning has been lost over time.</span>
00728                 <span class="comment">// Currently unused in sander or gibbs.</span>
00729         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00730 }
00731 <span class="comment">// FORMAT(12I6)  IPTRES, NSPM, NSPSOL</span>
00732 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"SOLVENT_POINTERS"</span>)==0){
00733         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo95">IPTRES</a> =pa; <span class="comment">// IPTRES : final residue that is considered part of the solute,</span>
00734                 <span class="comment">// reset in sander and gibbs</span>
00735         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo96">NSPM</a>   =pa; <span class="comment">// NSPM   : total number of molecules</span>
00736         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo97">NSPSOL</a> =pa; <span class="comment">// NSPSOL : the first solvent "molecule" </span>
00737         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00738         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>==3){
00739                 sscanf(P[0].S[pa].D[0],<span class="stringliteral">"%d"</span>,&amp;IPTRES);
00740                 sscanf(P[0].S[pa].D[1],<span class="stringliteral">"%d"</span>,&amp;NSPM);
00741                 sscanf(P[0].S[pa].D[2],<span class="stringliteral">"%d"</span>,&amp;NSPSOL);
00742                 }
00743 }
00744 <span class="comment">// FORMAT(12I6)  (NSP(i), i=1,NSPM)</span>
00745 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ATOMS_PER_MOLECULE"</span>)==0){
00746         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo98">NSP</a>    =pa; <span class="comment">// NSP    : the total number of atoms in each molecule,</span>
00747                 <span class="comment">// necessary to correctly perform the pressure scaling.  </span>
00748         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00749         NSP=(<span class="keywordtype">int</span>*)calloc(P[0].S[pa].nt,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00750         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;NSP[pb]);}
00751 }
00752 <span class="comment">// FORMAT(5E16.8)  BETA, BOX(1), BOX(2), BOX(3)</span>
00753 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BOX_DIMENSIONS"</span>)==0){
00754         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo99">BETA</a>   =pa; <span class="comment">// BETA   : periodic box, angle between the XY and YZ planes in degrees.</span>
00755         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo100">BOX</a>    =pa; <span class="comment">// BOX    : the periodic box lengths in the X, Y, and Z directions </span>
00756         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00757         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>==4){
00758                 sscanf(P[0].S[pa].D[0],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo26">boxang</a>);
00759                 sscanf(P[0].S[pa].D[1],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo24">boxl</a>.<a class="code" href="../../d8/d31/structcoord__3D.html#coord__3Do0">i</a>);
00760                 sscanf(P[0].S[pa].D[2],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo24">boxl</a>.<a class="code" href="../../d8/d31/structcoord__3D.html#coord__3Do1">j</a>);
00761                 sscanf(P[0].S[pa].D[3],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo24">boxl</a>.<a class="code" href="../../d8/d31/structcoord__3D.html#coord__3Do2">k</a>);
00762                 }
00763 }
00764 <span class="comment">// The following are only present if IFCAP .gt. 0 </span>
00765 <span class="comment">// FORMAT(12I6)  NATCAP</span>
00766 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"CAP_INFO"</span>)==0){
00767         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo101">NATCAP</a> =pa; <span class="comment">// NATCAP : last atom before the start of the cap of waters placed by edit </span>
00768         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00769 }
00770 <span class="comment">// FORMAT(5E16.8)  CUTCAP, XCAP, YCAP, ZCAP</span>
00771 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"CAP_INFO2"</span>)==0){ <span class="comment">// not putting this in quite yet</span>
00772         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo102">CUTCAP</a> =pa; <span class="comment">// CUTCAP : the distance from the center of the cap to the outside</span>
00773         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo103">XCAP</a>   =pa; <span class="comment">// XCAP   : X coordinate for the center of the cap</span>
00774         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo104">YCAP</a>   =pa; <span class="comment">// YCAP   : Y coordinate for the center of the cap</span>
00775         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo105">ZCAP</a>   =pa; <span class="comment">// ZCAP   : Z coordinate for the center of the cap </span>
00776         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00777 }
00778 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RADIUS_SET"</span>)==0){
00779         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00780         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>&gt;0){RADTYPE=strdup(P[0].S[pa].D[0]);}
00781 }
00782 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RADII"</span>)==0){
00783         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00784         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in RADII in parse_amber_prmtop."</span>);}
00785         R=(<span class="keywordtype">double</span>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00786         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;R[pb]);}
00787 }
00788 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"SCREEN"</span>)==0){
00789         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00790         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in SCREEN in parse_amber_prmtop."</span>);}
00791         SC=(<span class="keywordtype">double</span>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00792         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;SC[pb]);}
00793 }
00794 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_NTYP"</span>)==0){ <span class="comment">// leave these out for now</span>
00795         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00796 }
00797 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_TYPE"</span>)==0){
00798         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00799 }
00800 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_FAC"</span>)==0){
00801         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00802 }
00803 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_CNUM"</span>)==0){
00804         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00805 }
00806 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_ID"</span>)==0){
00807         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00808 }
00809 <span class="comment">// The following is only present if IFPERT .gt. 0</span>
00810 <span class="comment">/* Note that the initial state, or equivalently the prep/link/edit state, </span>
00811 <span class="comment">        is represented by lambda=1 and the perturbed state, or final state </span>
00812 <span class="comment">        specified in parm, is the lambda=0 state. */</span> 
00813 <span class="comment">// FORMAT(12I6)  (IBPER(i), JBPER(i), i=1,NBPER)</span>
00814 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_BOND_ATOMS"</span>)==0){
00815 <span class="comment">// The following are only present if IFBOX .gt. 0 </span>
00816         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo106">IBPER</a>  =pa; <span class="comment">// IBPER  : atoms involved in perturbed bonds</span>
00817         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo107">JBPER</a>  =pa; <span class="comment">// JBPER  : atoms involved in perturbed bonds </span>
00818         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00819 }
00820 <span class="comment">// FORMAT(12I6)  (ICBPER(i), i=1,2*NBPER)</span>
00821 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_BOND_PARAMS"</span>)==0){
00822         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo108">ICBPER</a> =pa; <span class="comment">// ICBPER : pointer into the bond parameter arrays RK and REQ for the</span>
00823         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00824 }
00825                 <span class="comment">// perturbed bonds.  ICBPER(i) represents lambda=1 and </span>
00826                 <span class="comment">// ICBPER(i+NBPER) represents lambda=0.  </span>
00827 <span class="comment">// FORMAT(12I6)  (ITPER(i), JTPER(i), KTPER(i), i=1,NGPER)</span>
00828 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ANGLE_ATOMS"</span>)==0){
00829         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo109">IPTER</a>  =pa; <span class="comment">// IPTER  : atoms involved in perturbed angles</span>
00830         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo110">JTPER</a>  =pa; <span class="comment">// JTPER  : atoms involved in perturbed angles</span>
00831         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo111">KTPER</a>  =pa; <span class="comment">// KTPER  : atoms involved in perturbed angles </span>
00832         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00833 }
00834 <span class="comment">// FORMAT(12I6)  (ICTPER(i), i=1,2*NGPER)</span>
00835 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ANGLE_PARAMS"</span>)==0){
00836         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo112">ICTPER</a> =pa; <span class="comment">// ICTPER : pointer into the angle parameter arrays TK and TEQ for </span>
00837         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00838 }
00839                 <span class="comment">// the perturbed angles.  ICTPER(i) represents lambda=0 and </span>
00840                 <span class="comment">// ICTPER(i+NGPER) represents lambda=1.  </span>
00841 <span class="comment">// FORMAT(12I6)  (IPPER(i), JPPER(i), KPPER(i), LPPER(i), i=1,NDPER)</span>
00842 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_DIHEDRAL_ATOMS"</span>)==0){
00843         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo113">IPPER</a>  =pa; <span class="comment">// IPPER  : atoms involved in perturbed dihedrals</span>
00844         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo114">JPPER</a>  =pa; <span class="comment">// JPPER  : atoms involved in perturbed dihedrals</span>
00845         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo115">KPPER</a>  =pa; <span class="comment">// KPPER  : atoms involved in perturbed dihedrals</span>
00846         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo116">LPPER</a>  =pa; <span class="comment">// LPPER  : atoms involved in pertrubed dihedrals </span>
00847         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00848 }
00849 <span class="comment">// FORMAT(12I6)  (ICPPER(i), i=1,2*NDPER)</span>
00850 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_DIHEDRAL_PARAMS"</span>)==0){
00851         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo117">ICPPER</a> =pa; <span class="comment">// ICPPER : pointer into the dihedral parameter arrays PK, PN and</span>
00852         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00853 }
00854                 <span class="comment">// PHASE for the perturbed dihedrals.  ICPPER(i) represents </span>
00855                 <span class="comment">// lambda=1 and ICPPER(i+NGPER) represents lambda=0.  </span>
00856 <span class="comment">// FORMAT(20A4)  (LABRES(i), i=1,NRES)</span>
00857 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_RESIDUE_NAME"</span>)==0){
00858         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo50">LABRES</a> =pa; <span class="comment">// LABRES : residue names at lambda=0 </span>
00859         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00860 }
00861 <span class="comment">// FORMAT(20A4)  (IGRPER(i), i=1,NATOM)</span>
00862 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ATOM_NAME"</span>)==0){
00863         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo119">IGRPER</a> =pa; <span class="comment">// IGRPER : atomic names at lambda=0 </span>
00864         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00865 }
00866 <span class="comment">// FORMAT(20A4)  (ISMPER(i), i=1,NATOM)</span>
00867 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ATOM_SYMBOL"</span>)==0){
00868         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo120">ISMPER</a> =pa; <span class="comment">// ISMPER : atomic symbols at lambda=0 </span>
00869         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00870 }
00871 <span class="comment">// FORMAT(5E16.8)  (ALMPER(i), i=1,NATOM)</span>
00872 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ALMPER"</span>)==0){
00873         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo121">ALMPER</a> =pa; <span class="comment">// ALMPER : unused currently in gibbs </span>
00874         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00875 }
00876 <span class="comment">// FORMAT(12I6)  (IAPER(i), i=1,NATOM)</span>
00877 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"IAPER"</span>)==0){
00878         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo122">IAPER</a>  =pa; <span class="comment">// IAPER  : IAPER(i) = 1 if the atom is being perturbed </span>
00879         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00880 }
00881 <span class="comment">// FORMAT(12I6)  (IACPER(i), i=1,NATOM)</span>
00882 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ATOM_TYPE_INDEX"</span>)==0){
00883         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo123">IACPER</a> =pa; <span class="comment">// IACPER : index for the atom types involved in Lennard Jones</span>
00884         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00885 }
00886                 <span class="comment">// interactions at lambda=0.  Similar to IAC above.  See ICO above.  </span>
00887 <span class="comment">// FORMAT(5E16.8)  (CGPER(i), i=1,NATOM)</span>
00888 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_CHARGE"</span>)==0){
00889         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo124">CGPER</a>  =pa; <span class="comment">// CGPER  : atomic charges at lambda=0 </span>
00890         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00891 }
00892 <span class="comment">// The following is only present if IPOL .eq. 1 </span>
00893 <span class="comment">// FORMAT(5E18.8) (ATPOL(i), i=1,NATOM)</span>
00894 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"POLARIZABILITY"</span>)==0){ <span class="comment">// leave out for now</span>
00895         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo125">ATPOL</a>  =pa; <span class="comment">// ATPOL  : atomic polarizabilities </span>
00896         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00897 }
00898 <span class="comment">// The following is only present if IPOL .eq. 1 .and. IFPERT .eq. 1 </span>
00899 <span class="comment">// FORMAT(5E18.8) (ATPOL1(i), i=1,NATOM)</span>
00900 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_POLARIZABILITY"</span>)==0){
00901         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo126">ATPOL1</a> =pa; <span class="comment">// ATPOL1 : atomic polarizabilities at lambda = 1 (above is at lambda = 0) </span>
00902         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00903 }
00904         } <span class="comment">// close loop through each section in the prmtop structure</span>
00905 
00906 F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>=<a class="code" href="../../df/da0/group__FILE__UTILS.html#ga0">myfopen</a>(<span class="stringliteral">"test_rewrite_of_prmtop"</span>,<span class="stringliteral">"w"</span>);
00907 fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%s"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo1">VERSION</a>);
00908 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo2">nS</a>;pa++){ <span class="comment">// for each section found</span>
00909         fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%%FLAG %s\n"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono0">N</a>);
00910         fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%%FORMAT(%s)\n"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono1">FORMAT</a>);
00911         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){
00912                 fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%s"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono10">D</a>[pb]);
00913                 <span class="comment">//fprintf(F.F,"D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pb,P[0].S[pa].D[pb]);</span>
00914                 fflush(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>);
00915 <span class="comment">//printf("\npb is %d ; P[0].S[%d].npl is %d ; (pb+1)%%npl is %d\n",pb,pa,P[0].S[pa].npl,);</span>
00916                 <span class="keywordflow">if</span>((((pb+1)%P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono6">npl</a>))==0){fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"\n"</span>);} 
00917                 <span class="comment">//if((((pb+1)*P[0].S[pa].nc))%80==0){printf("\n");} </span>
00918                 }
00919         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>==0){fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"\n"</span>);}
00920         <span class="keywordflow">if</span>(((pb)*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono5">nc</a>)%80!=0){fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"\n"</span>);} 
00921         }
00922 fclose(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>);
00923 
00924 <span class="comment">// Set the names of the atom types in the type array</span>
00925 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pa++){ A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pa][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>].<a class="code" href="../../dc/d7a/structatype.html#atypeo1">N</a>=strdup(ATNAME[pa]); }
00926 <span class="comment">// Now set the names in the non-bonded bond type array</span>
00927 <span class="comment">// -- set atom information in the LJ type arrays</span>
00928 <span class="comment">//int *ICO,nICO;</span>
00929 <span class="keywordflow">if</span>(nICO!=(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>*A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>)){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"nICO!=(A.PRM[0].nAT*A.PRM[0].nAT) in parse_amber_prmtop"</span>);}
00930 <span class="comment">// For example, for atoms i and j, with i &lt; j, the index is</span>
00931 <span class="comment">// ICO(NTYPES*(IAC(i)-1)+IAC(j)).  </span>
00932 pI1=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>*(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>+1)/2;
00933 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>;pa++){ <span class="comment">// this is index 'j' in the prmtop file</span>
00934 <span class="keywordflow">for</span>(pb=0;pb&lt;(pa+1);pb++){ <span class="comment">// this is index 'i' in the prmtop file</span>
00935         <span class="comment">// allocate space for the names of the two atom types</span>
00936         pc=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>*pb+pa;
00937         <span class="keywordflow">if</span>(pc&gt;nICO){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"pc&gt;nICO in parse_amber_prmtop"</span>);}
00938         <span class="keywordflow">if</span>(ICO[pc]&gt;pI1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"ICO[pc]&gt;(P[0].NTYPES*(P[0].NTYPES+1)/2) in parse_amber_prmtop"</span>);}
00939         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[ICO[pc]].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo0">NT</a>=(<span class="keywordtype">char</span>**)calloc(2,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00940         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[ICO[pc]].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo0">NT</a>[0]=strdup(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>[pb].<a class="code" href="../../dc/d7a/structatype.html#atypeo1">N</a>);
00941         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[ICO[pc]].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo0">NT</a>[1]=strdup(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>[pa].<a class="code" href="../../dc/d7a/structatype.html#atypeo1">N</a>);
00942         }
00943 }
00944 
00945 <span class="comment">// set molecule information</span>
00946 <span class="comment">//      First, copy MOLI &amp; MB arrays for safety &amp; record</span>
00947 MOLBNDI=(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>*)calloc(P[0].NATOM,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>));
00948 MBTMP=(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>));
00949 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>;pa++){ MOLBNDI[pa]=MOLI[pa]; }
00950 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>;pa++){ 
00951         MBTMP[pa]=MB[pa]; 
00952 <span class="comment">//printf("MBTMP[%d].s.i is %d ; MBTMP[%d].t.i is %d \n",pa,MBTMP[pa].s.i,pa,MBTMP[pa].t.i);</span>
00953 <span class="comment">//printf("MB[%d].s.i is %d ; MB[%d].t.i is %d \n",pa,MB[pa].s.i,pa,MB[pa].t.i);</span>
00954         }
00955 <span class="comment">// call the "find molecules" function</span>
00956 <a class="code" href="../../d2/d2a/find__molecules_8c.html#a1">find_molecules_molbond_array</a>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>, MBTMP, P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>, MOLBNDI);
00957 
00958 <span class="comment">// Rearrange the structures to reflect the new molecule information</span>
00959 <span class="comment">// 1. Find numbers of molecules and make space</span>
00960 <span class="comment">//      The molecules, coming from find_molecules_molbond_array, should count </span>
00961 <span class="comment">//      sequentially starting with zero.</span>
00962 <span class="comment">// 2. While we're at it, associate each residue with a molecule in a convenient array (resi)</span>
00963 nummol=0;
00964 resi=(<span class="keywordtype">int</span>*)calloc(P[0].NRES,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00965 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo25">NRES</a>;pa++){ resi[pa]=-1; }
00966 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>;pa++){ 
00967         <span class="keywordflow">if</span>(MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>&gt;nummol){ nummol = MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>; }  <span class="comment">// find numbers of molecules</span>
00968         <span class="keywordflow">if</span>(resi[MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>]==-1) resi[MOLBNDI[pa].r]=MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
00969         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(resi[MOLBNDI[pa].r]!=MOLBNDI[pa].m){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"resi[MOLBNDI[pa].r]!=MOLBNDI[pa].m in parse_amber_prmtop"</span>);} 
00970 <span class="comment">//printf("pa is %d ; MOLBNDI[pa].r is %d . . . resi[MOLBNDI[pa].r] ===  %d\n",pa,MOLBNDI[pa].r,resi[MOLBNDI[pa].r]);</span>
00971         }
00972 nummol++;
00973 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>=nummol; <span class="comment">// make space for the molecules</span>
00974 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>=(<a class="code" href="../../dc/d7f/structmolecule.html">molecule</a>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../dc/d7f/structmolecule.html">molecule</a>*));
00975 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>;pa++){ 
00976         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa]=(molecule*)calloc(1,<span class="keyword">sizeof</span>(molecule)); 
00977         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo8">na</a>=0;
00978         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>=0;
00979         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo9">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>**)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>*));
00980         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>));
00981         }
00982 <span class="comment">// place residues into molecule structures -- and do a little housekeeping</span>
00983 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo25">NRES</a>;pa++){
00984         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo0">n</a>=pa+1; <span class="comment">// the file-print residue "number"</span>
00985         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>++;
00986         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>));
00987         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>-1]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0]; <span class="comment">// copy over residue </span>
00988         <span class="comment">//free(A.r[pa]); // free space</span>
00989         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa]=&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>-1];<span class="comment">// reassign pointer</span>
00990 <span class="comment">//printf("A.r[pa][0].na is %d\n",A.r[pa][0].na);</span>
00991         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>;pb++){
00992 <span class="comment">//printf("\tA.r[%d][0].a[%d].n is %d  ;  MOLBNDI[A.r[pa][0].a[pb].n-1].r is %d \n",pa,pb,A.r[pa][0].a[pb].n,MOLBNDI[A.r[pa][0].a[pb].n-1].r); </span>
00993                 MOLBNDI[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pb].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>-1].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>-1;
00994 <span class="comment">//printf("\t\t MOLBNDI[A.r[pa][0].a[pb].n-1].r is %d \n",MOLBNDI[A.r[pa][0].a[pb].n-1].r);</span>
00995                 }
00996 <span class="comment">//printf("Residue index %d has name &gt;&gt;&gt;%s&lt;&lt;&lt; (A.r[pa][0].N) or &gt;&gt;&gt;%s&lt;&lt;&lt; (thru the mol)\n",pa,A.r[pa][0].N,A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].N);</span>
00998 <span class="comment"></span><span class="comment">//printf("\t na is %d \n",A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].na); </span>
00999 <span class="comment">//for(pb=0;pb&lt;A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].na;pb++){</span>
01000 <span class="comment">//printf("\tAtom #%d is named &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pb,A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].a[pb].N);</span>
01001 <span class="comment">//}</span>
01002         }
01003 
01004 
01005 <span class="comment">//for(pa=0;pa&lt;A.nm;pa++){</span>
01006 <span class="comment">//printf("============== there are %d molecules =================\n",A.nm);</span>
01007 <span class="comment">//dprint_molecule(A.m[pa],1000);}</span>
01008 
01009 <span class="comment">// if the NSPM &amp; NSP information is present, check results for consistency</span>
01010 <span class="comment">// NSPM = number of molecules</span>
01011 <span class="comment">// *NSP = number of atoms in each molecule</span>
01012 <span class="comment">// IPTRES = last residue that is solute</span>
01013 <span class="comment">// NSPSOL = first solvent residue</span>
01014 <span class="comment">//</span>
01015 <span class="comment">// Use new molecule information to reset residue numbers and molecule affiliations</span>
01016 <span class="comment">//      set the MOLI indices, too...</span>
01017 <span class="comment">//</span>
01018 <span class="comment">// START HERE -- when the above is finished, rewrite the following....</span>
01019 <span class="comment">// Set the bond information at the atom level</span>
01020 
01021 printf(<span class="stringliteral">"============== there are %d molecules =================\n"</span>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>);
01022 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>;pa++){
01023 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo1">N</a>=strdup(<span class="stringliteral">"unknown"</span>);
01024 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo2">D</a>=strdup(<span class="stringliteral">"Molecule determined by read of Amber prmtop file"</span>);
01025 <span class="comment">//printf("\tMolecule %d contains %d residues\n",pa,A.m[pa][0].nr);</span>
01026 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>;pb++){
01027 <span class="comment">//printf("\t\tResidue %d contains %d atoms\n",pb,A.m[pa][0].r[pb].na);</span>
01028 <span class="keywordflow">for</span>(pc=0;pc&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>;pc++){
01029         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>=(molbond*)calloc(1,<span class="keyword">sizeof</span>(molbond)); 
01030 <span class="comment">//printf("Atom %s (# %d) belongs to residue # %d and molecule # %d\n",A.m[pa][0].r[pb].a[pc].N,pc,pb,pa);</span>
01031         }
01032         }
01033         }
01034 <span class="comment">//for(pa=0;pa&lt;A.na;pa++){</span>
01035 <span class="comment">//printf("MOLBNDI[pa=%d] i is %d ; m is %d ; r is %d ; a is %d\n",pa,MOLBNDI[pa].i,MOLBNDI[pa].m,MOLBNDI[pa].r,MOLBNDI[pa].a);</span>
01036 <span class="comment">//if(pa&gt;150) exit(0);</span>
01037 <span class="comment">//}</span>
01038 
01039 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>;pa++){
01040         <span class="comment">// set global bonds</span>
01041         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>=MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>;
01042         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo5">D</a>=strdup(MBTMP[pa].D);
01043         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=sm=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01044         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=sr=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01045         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=sa=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01046         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=tm=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01047         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=tr=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01048         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=ta=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01049 <span class="comment">/*</span>
01050 <span class="comment">printf("bond number, pa=%d \n",pa);</span>
01051 <span class="comment">printf("  MBTMP[pa].s.i is %d \n",MBTMP[pa].s.i);</span>
01052 <span class="comment">printf("    MBTMP[pa].t.i is %d\n",MBTMP[pa].t.i);</span>
01053 <span class="comment">printf("\tMOLBNDI[(s)].m =%d \n",MOLBNDI[MBTMP[pa].s.i].m);</span>
01054 <span class="comment">printf("\t\t .r=%d \n",MOLBNDI[MBTMP[pa].s.i].r);</span>
01055 <span class="comment">printf("\t\t    .a=%d\n",MOLBNDI[MBTMP[pa].s.i].a);</span>
01056 <span class="comment">printf("\t\tMOLBNDI[(t)].m =%d \n",MOLBNDI[MBTMP[pa].t.i].m);</span>
01057 <span class="comment">printf("\t\t\t  .r=%d \n",MOLBNDI[MBTMP[pa].t.i].r);</span>
01058 <span class="comment">printf("\t\t\t    .a=%d\n",MOLBNDI[MBTMP[pa].t.i].a);</span>
01059 <span class="comment">*/</span>
01060         <span class="comment">// -- set local bonds to molbond structure (later to local bond structure)</span>
01061         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>++;
01062         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>++;
01063         <span class="comment">// START HERE -- make sure these are allocated somewhere first.....</span>
01064         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>=(molbond*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>*<span class="keyword">sizeof</span>(molbond));
01065         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>=(molbond*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>*<span class="keyword">sizeof</span>(molbond));
01066         <span class="comment">// set both atoms as being bonded to the other</span>
01067         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa]; <span class="comment">// if already "source", all is ok</span>
01068         <span class="comment">// if the atom is a "target", we have to turn things around a bit</span>
01069         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01070         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01071         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01072         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a> ;
01073         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a> ;
01074         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a> ;
01075         }
01076 
01077 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>;pa++){
01078 printf(<span class="stringliteral">"MOLECULE #%d\n"</span>,pa);
01079 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>;pb++){
01080 printf(<span class="stringliteral">"\tRESIDUE #%d (name %s)\n"</span>,pb,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>); 
01081 <span class="keywordflow">for</span>(pc=0;pc&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>;pc++){
01082 printf(<span class="stringliteral">"\t\tATOM #%d (name %s) has %d bonds\n"</span>,pc,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>); 
01083 <span class="keywordflow">for</span>(pd=0;pd&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>;pd++){
01084 tm=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[pd].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01085 tr=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[pd].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01086 ta=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[pd].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01087 printf(<span class="stringliteral">"\t\t\tTo %s (atom number %d)\n"</span>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>);
01088 }
01089 }
01090 }
01091 }
01092 <span class="comment">//      -- MOLI[i] contains residue and atom info per each linear-numbered atom</span>
01093 <span class="comment">// -- set local torsions and angles</span>
01094 <span class="comment">// -- set connection tree after all that...</span>
01095 <span class="comment">//      -- check this tree against the amber tree info for sanity</span>
01096 <span class="comment">//int IPTRES=0,NSPM=0,NSPSOL=0,*NSP; // solvent/solute info &amp; #atoms per molecule</span>
01097 <span class="comment">//molbond *MB;</span>
01098 <span class="comment">//angle_index *MANG;</span>
01099 <span class="comment">//torsion_index *MTOR;</span>
01100 <span class="comment">//char **ATNAME,**TREECLASS,*RADTYPE;</span>
01101 <span class="comment">//double *R,*SC,*MASS; // radii and screening constants for IS, atom masses</span>
01102 <span class="comment">//fileset F;</span>
01103 <span class="comment">//</span>
01104 
01105 
01106 <span class="keywordflow">return</span> A;
01107 }
01108 
01109 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jul 22 12:10:50 2008 for GLYLIB by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
