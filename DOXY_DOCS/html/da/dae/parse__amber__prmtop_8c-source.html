<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GLYLIB: src/parse_amber_prmtop.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../modules.html">Modules</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../dirs.html">Directories</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="../../dir_000002.html">src</a></div>
<h1>parse_amber_prmtop.c</h1><a href="../../db/d7d/parse__amber__prmtop_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/* File parse_amber_prmtop.c begun on 20080610 by BLFoley</span>
00002 <span class="comment"> * Purpose: parse entries from prmtop file (already read in) into</span>
00003 <span class="comment"> *      appropriate data locations within an assembly</span>
00004 <span class="comment"> *      Also adds the prmtop P to the assembly's void pointer</span>
00005 <span class="comment"> */</span>
00006 <span class="preprocessor">#include "<a class="code" href="../../d6/d78/amber__prmtop_8h.html">AMBER/amber_prmtop.h</a>"</span>
00007 
<a name="l00008"></a><a class="code" href="../../db/d7d/parse__amber__prmtop_8c.html#a0">00008</a> <a class="code" href="../../db/dac/structassembly.html">assembly</a> <a class="code" href="../../db/d7d/parse__amber__prmtop_8c.html#a0">parse_amber_prmtop</a>(<a class="code" href="../../de/de7/structamber__prmtop.html">amber_prmtop</a> *P){
00009 <a class="code" href="../../db/dac/structassembly.html">assembly</a> A;
00010 <span class="keywordtype">int</span> *ICO,nICO;
00011 <span class="keywordtype">int</span> pa=0,pb=0,pc=0,pd=0,pA1=0,pA2=0,pA3,pA4,pI1=0;
00012 <span class="keywordtype">int</span> NextRes=0,nummol=0,*resi; <span class="comment">// more utility integers</span>
00013 <span class="keywordtype">int</span> sa=0,sr=0,sm=0,ta=0,tr=0,tm=0;
00014 <span class="keywordtype">int</span> IPTRES=0,NSPM=0,NSPSOL=0,*NSP; <span class="comment">// solvent/solute info &amp; #atoms per molecule</span>
00015 <a class="code" href="../../df/d7e/structmolbond.html">molbond</a> *MB,*MBTMP;
00016 <a class="code" href="../../da/d09/structangle__index.html">angle_index</a> *MANG;
00017 <a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a> *MTOR;
00018 <a class="code" href="../../d2/d4f/structmolindex.html">molindex</a> *MOLI,*MOLBNDI; <span class="comment">// MOLI for here, MOLBNDI for assigning molecules</span>
00019 <span class="keywordtype">char</span> **ATNAME,**TREECLASS,*RADTYPE,tmp[80];
00020 <span class="keywordtype">double</span> *R,*SC,*MASS; <span class="comment">// radii and screening constants for IS, atom masses</span>
00021 <a class="code" href="../../dc/d59/structfileset.html">fileset</a> F;
00022 <a class="code" href="../../de/de7/structamber__prmtop.html">amber_prmtop</a> *aprm;
00023 
00025 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo32">nVP</a>=1; 
00026 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo33">VP</a>=P;
00027 
00028 <span class="comment">// do some initializations</span>
00029 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo20">nPRM</a>=1;
00030 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>=(<a class="code" href="../../db/d68/structparameter__set.html">parameter_set</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../db/d68/structparameter__set.html">parameter_set</a>));
00031 
00032 <span class="comment">// First, find the pointers and read them into the top structure</span>
00033 <span class="comment">// Also add them to the assembly, as needed</span>
00034 <span class="comment">// Any that are not added now can be added later -- chances are that </span>
00035 <span class="comment">//      no one had a use for them previously.  In any case, they will</span>
00036 <span class="comment">//      be present as-is in the void pointer</span>
00037 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo2">nS</a>;pa++){ <span class="comment">// get pointers first...</span>
00038         <span class="keywordflow">if</span>(strcmp(P[0].SN[pa],<span class="stringliteral">"POINTERS"</span>)==0){ 
00039                 <span class="comment">// total number of atoms</span>
00040                 sscanf(P[0].S[pa].D[0],<span class="stringliteral">"%d"</span>,&amp;P[0].NATOM); 
00041                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>; 
00042                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>&gt;0){
00043                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>*));
00044                         MOLI=(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>)); <span class="comment">// to keep up with locations per atom</span>
00045                         } 
00046                 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb]=(<a class="code" href="../../da/d81/structatom.html">atom</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>));}
00047                 <span class="comment">// number of atom types</span>
00048                 sscanf(P[0].S[pa].D[1],<span class="stringliteral">"%d"</span>,&amp;P[0].NTYPES); 
00049                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>; 
00050                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>&gt;0){
00051                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>=(<a class="code" href="../../dc/d7a/structatype.html">atype</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../dc/d7a/structatype.html">atype</a>));
00052                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>*(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>+1)/2;
00053                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>=(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>));
00054                         nICO=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>*A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>;
00055                         ICO=(<span class="keywordtype">int</span>*)calloc(nICO,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00056                         } 
00057                 <span class="comment">// Numbers of actual bonds, angles, dihedrals</span>
00058                 <span class="comment">// NOT adding these number-of distinctions to the assembly</span>
00059                 <span class="comment">// Instead, adding them all as plain bonds, etc. (see "D" description for distinction)</span>
00060                 <span class="comment">// See also NBONA, etc., below (constraints)...</span>
00061                 sscanf(P[0].S[pa].D[2],<span class="stringliteral">"%d"</span>,&amp;P[0].NBONH); <span class="comment">// number of bonds containing hydrogen</span>
00062                 sscanf(P[0].S[pa].D[3],<span class="stringliteral">"%d"</span>,&amp;P[0].MBONA); <span class="comment">// number of bonds not containing hydrogen</span>
00063                 sscanf(P[0].S[pa].D[4],<span class="stringliteral">"%d"</span>,&amp;P[0].NTHETH); <span class="comment">// number of angles containing hydrogen</span>
00064                 sscanf(P[0].S[pa].D[5],<span class="stringliteral">"%d"</span>,&amp;P[0].MTHETA); <span class="comment">// number of angles not containing hydrogen</span>
00065                 sscanf(P[0].S[pa].D[6],<span class="stringliteral">"%d"</span>,&amp;P[0].NPHIH); <span class="comment">// number of dihedrals containing hydrogen</span>
00066                 sscanf(P[0].S[pa].D[7],<span class="stringliteral">"%d"</span>,&amp;P[0].MPHIA); <span class="comment">// number of dihedrals not containing hydrogen</span>
00067                 <span class="comment">// Unused parameters and the excluded atoms list (probably not used in glycam)</span>
00068                 <span class="comment">// NOT adding these at all</span>
00069                 sscanf(P[0].S[pa].D[8],<span class="stringliteral">"%d"</span>,&amp;P[0].NHPARM); <span class="comment">// currently not used</span>
00070                 sscanf(P[0].S[pa].D[9],<span class="stringliteral">"%d"</span>,&amp;P[0].NPARM); <span class="comment">// currently not used</span>
00071                 sscanf(P[0].S[pa].D[10],<span class="stringliteral">"%d"</span>,&amp;P[0].NEXT); <span class="comment">// number of excluded atoms</span>
00072                 <span class="comment">// Number of residues</span>
00073                 sscanf(P[0].S[pa].D[11],<span class="stringliteral">"%d"</span>,&amp;P[0].NRES); 
00074                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo25">NRES</a>; 
00075                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*));} <span class="comment">// will move these later </span>
00076                 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>;pb++){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb]=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>));}
00077                 <span class="comment">// The rest of the bonds, angles and torsions (constraints)</span>
00078                 sscanf(P[0].S[pa].D[12],<span class="stringliteral">"%d"</span>,&amp;P[0].NBONA); <span class="comment">// MBONA + number of constraint bonds</span>
00079                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a> + P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo26">NBONA</a>; <span class="comment">// all the bonds</span>
00080                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>=(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>));}
00081                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>&gt;0){MB=(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>));}
00082                 sscanf(P[0].S[pa].D[13],<span class="stringliteral">"%d"</span>,&amp;P[0].NTHETA); <span class="comment">// MTHETA + number of constraint angles</span>
00083                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo27">NTHETA</a>; <span class="comment">// all the angles</span>
00084                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo17">ANG</a>=(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>));}
00085                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>&gt;0){MANG=(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo16">nANG</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d09/structangle__index.html">angle_index</a>));}
00086                 sscanf(P[0].S[pa].D[14],<span class="stringliteral">"%d"</span>,&amp;P[0].NPHIA); <span class="comment">// MPHIA + number of constraint dihedrals</span>
00087                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo28">NPHIA</a>; <span class="comment">// all the torsions</span>
00088                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo19">TOR</a>=(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>));}
00089                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>&gt;0){MTOR=(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo18">nTOR</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d3d/structtorsion__index.html">torsion_index</a>));}
00090                 <span class="comment">// Numbers of bond, angle and torsion types</span>
00091                 sscanf(P[0].S[pa].D[15],<span class="stringliteral">"%d"</span>,&amp;P[0].NUMBND); <span class="comment">// number of unique bond types</span>
00092                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo29">NUMBND</a>; <span class="comment">// number of unique bond types</span>
00093                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto7">BT</a>=(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>));}
00094                 sscanf(P[0].S[pa].D[16],<span class="stringliteral">"%d"</span>,&amp;P[0].NUMANG); <span class="comment">// number of unique angle types</span>
00095                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo30">NUMANG</a>; <span class="comment">// number of unique angle types</span>
00096                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto13">ANT</a>=(<a class="code" href="../../dc/ddd/structangle__type.html">angle_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../dc/ddd/structangle__type.html">angle_type</a>));}
00097                 sscanf(P[0].S[pa].D[17],<span class="stringliteral">"%d"</span>,&amp;P[0].NPTRA); <span class="comment">// number of unique dihedral types</span>
00098                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo31">NPTRA</a>; <span class="comment">// number of unique dihedral types</span>
00099                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>=(<a class="code" href="../../da/d03/structtorsion__type.html">torsion_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d03/structtorsion__type.html">torsion_type</a>));}
00100                 <span class="comment">// Number of atom types in parameter file</span>
00101                 <span class="comment">// NOT adding this at all at present</span>
00102                 sscanf(P[0].S[pa].D[18],<span class="stringliteral">"%d"</span>,&amp;P[0].NATYP); <span class="comment">// number of atom types in parameter file, see SOLTY below</span>
00103                 <span class="comment">// Number of Lennard-Jones 10-12 H-Bond pair types</span>
00104                 sscanf(P[0].S[pa].D[19],<span class="stringliteral">"%d"</span>,&amp;P[0].NPHB); <span class="comment">// number of distinct 10-12 hydrogen bond pair types</span>
00105                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto8">nHBT</a> = P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo33">NPHB</a>;
00106                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto8">nHBT</a>&gt;0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto9">HBT</a>=(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto8">nHBT</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../d6/def/structbond__type.html">bond_type</a>));}
00107                 <span class="comment">// Perturbation information</span>
00108                 <span class="comment">// NOT adding these at all (no longer used as of AMBER 10)</span>
00109                 sscanf(P[0].S[pa].D[20],<span class="stringliteral">"%d"</span>,&amp;P[0].IFPERT); <span class="comment">// set to 1 if perturbation info is to be read in</span>
00110                 sscanf(P[0].S[pa].D[21],<span class="stringliteral">"%d"</span>,&amp;P[0].NBPER); <span class="comment">// number of bonds to be perturbed</span>
00111                 sscanf(P[0].S[pa].D[22],<span class="stringliteral">"%d"</span>,&amp;P[0].NGPER); <span class="comment">// number of angles to be perturbed</span>
00112                 sscanf(P[0].S[pa].D[23],<span class="stringliteral">"%d"</span>,&amp;P[0].NDPER); <span class="comment">// number of dihedrals to be perturbed</span>
00113                 sscanf(P[0].S[pa].D[24],<span class="stringliteral">"%d"</span>,&amp;P[0].MBPER); <span class="comment">// number of bonds with atoms completely in perturbed group</span>
00114                 sscanf(P[0].S[pa].D[25],<span class="stringliteral">"%d"</span>,&amp;P[0].MGPER); <span class="comment">// number of angles with atoms completely in perturbed group</span>
00115                 sscanf(P[0].S[pa].D[26],<span class="stringliteral">"%d"</span>,&amp;P[0].MDPER); <span class="comment">// number of dihedrals with atoms completely in perturbed groups</span>
00116                 <span class="comment">// Box information</span>
00117                 sscanf(P[0].S[pa].D[27],<span class="stringliteral">"%d"</span>,&amp;P[0].IFBOX); <span class="comment">// set to 1 if standard periodic box, 2 when truncated octahedral</span>
00118                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>==0){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"none"</span>);}
00119                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>==1){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"standard periodic"</span>);}
00120                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>==2){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"truncated octahedral"</span>);}
00121                 <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo41">IFBOX</a>&gt;2){A.<a class="code" href="../../db/dac/structassembly.html#assemblyo27">boxtype</a>=strdup(<span class="stringliteral">"unknown box type"</span>);}
00122                 <span class="comment">// NOT adding these at all </span>
00123                 sscanf(P[0].S[pa].D[28],<span class="stringliteral">"%d"</span>,&amp;P[0].NMXRS); <span class="comment">// number of atoms in the largest residue</span>
00124                 sscanf(P[0].S[pa].D[29],<span class="stringliteral">"%d"</span>,&amp;P[0].IFCAP); <span class="comment">// set to 1 if the CAP option from edit was specified</span>
00125                 <span class="comment">//</span>
00126                 <span class="keywordflow">break</span>; <span class="comment">// no need to keep scanning...</span>
00127                 }
00128         }
00129 
00130 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo2">nS</a>;pa++){<span class="comment">// Loop through each of the sections</span>
00131         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a> = 1; <span class="comment">// Set is_standard to one as default</span>
00132         <span class="comment">//      check against each standard section</span>
00133         <span class="comment">//      if there is a match:</span>
00134         <span class="comment">//              set is_standard to zero</span>
00135         <span class="comment">//              record to assembly as needed</span>
00136         <span class="comment">//</span>
00137 
00138 <span class="comment">//FORMAT(20a4)  (ITITL(i), i=1,20)</span>
00139 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"TITLE"</span>)==0){ <span class="comment">// place in the Assembly description</span>
00140         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo12">ITITL</a> = pa; <span class="comment">// the title section </span>
00141         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00142         <span class="comment">// copy the title into the assembly's description</span>
00143         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo2">D</a>=(<span class="keywordtype">char</span>*)calloc(P[0].S[pa].nt*P[0].S[pa].nc+1,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00144         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){strcat(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo2">D</a>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono10">D</a>[pb]);}
00145 }
00146 <span class="comment">//FORMAT(12i6) </span>
00147 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"POINTERS"</span>)==0){ <span class="comment">// these are already added</span>
00148         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo13">POINTERS</a>=pa; <span class="comment">// pointer to the section containing the original char-strings</span>
00149         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00150 }
00151 <span class="comment">// FORMAT(20a4)  (IGRAPH(i), i=1,NATOM)</span>
00152 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ATOM_NAME"</span>)==0){ <span class="comment">// these eventually go into the molecules/residues/etc</span>
00153         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo44">IGRAPH</a>=pa; <span class="comment">// IGRAPH : the user atoms names </span>
00154         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00155         <span class="comment">// for now, add these to the straight list of Assembly atoms</span>
00156 <span class="comment">//printf("A.na is %d\n",A.na);</span>
00157         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in ATOM_NAME in parse_amber_prmtop"</span>);}
00158         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00159                 <span class="comment">//A.a[pb][0].N=(char*)calloc((P[0].S[pa].nc+1),sizeof(char));</span>
00160 <span class="comment">//printf("P[0].S[%d].D[%d] is ",pa,pb);</span>
00161 <span class="comment">//printf("&gt;&gt;&gt;%s&lt;&lt;&lt;\n",P[0].S[pa].D[pb]);</span>
00162                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,tmp);
00163                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>=(<span class="keywordtype">char</span>*)calloc((strlen(tmp)+1),<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00164                 strcpy(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>,tmp);
00165                 <span class="comment">//sscanf(P[0].S[pa].D[pb],"%s",A.a[pb][0].N);</span>
00166 <span class="comment">//printf("P[0].S[pa].D[pb] is &gt;&gt;&gt;%s&lt;&lt;&lt; and A.a[pb][0].N is &gt;&gt;&gt;%s&lt;&lt;&lt; (strlen %d)\t",P[0].S[pa].D[pb],A.a[pb][0].N,strlen(A.a[pb][0].N));</span>
00167                 <span class="comment">//A.a[pb][0].N=(char*)realloc(A.a[pb][0].N,strlen(A.a[pb][0].N+1));</span>
00168 <span class="comment">//printf("P[0].S[pa].D[pb] is &gt;&gt;&gt;%s&lt;&lt;&lt; and A.a[pb][0].N is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",P[0].S[pa].D[pb],A.a[pb][0].N);</span>
00169 
00170                 }
00171 }
00172 <span class="comment">// FORMAT(5E16.8)  (CHRG(i), i=1,NATOM)</span>
00173 <span class="comment">// (Divide by 18.2223 to convert to charge in units of the electron charge) </span>
00174 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"CHARGE"</span>)==0){ <span class="comment">// these go with each atom</span>
00175         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo45">CHRG</a>   =pa; <span class="comment">// CHRG   : the atom charges.  </span>
00176         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00177         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in CHARGE in parse_amber_prmtop"</span>);}
00178         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00179                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo16">nch</a>=1;
00180                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo17">ch</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00181                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo17">ch</a>[0]);
00182                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo17">ch</a>[0]/=18.2223;
00183                 }
00184 }
00185 <span class="comment">// FORMAT(5E16.8)  (AMASS(i), i=1,NATOM)</span>
00186 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"MASS"</span>)==0){ <span class="comment">// with each atom</span>
00187         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo46">AMASS</a>  =pa; <span class="comment">// AMASS  : the atom masses </span>
00188         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00189         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in AMASS in parse_amber_prmtop"</span>);}
00190         MASS=(<span class="keywordtype">double</span>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00191         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;MASS[pb]);}
00192         <span class="comment">//for(pb=0;pb&lt;A.na;pb++){sscanf(P[0].S[pa].D[pb],"%lf",&amp;A.a[pb][0].m);}</span>
00193 }
00194 <span class="comment">// FORMAT(12I6)  (IAC(i), i=1,NATOM)</span>
00195 <span class="comment">// START HERE -- is this really just an atom type index?  One hopes...</span>
00196 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ATOM_TYPE_INDEX"</span>)==0){ <span class="comment">// into the atype structure</span>
00197         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo47">IAC</a>    =pa; <span class="comment">// IAC    : index for the atom types involved in Lennard Jones (6-12) </span>
00198         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00199         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in ATOM_TYPE_INDEX in parse_amber_prmtop"</span>);}
00200         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00201                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>);
00202                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>--;
00203                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pb][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>&lt;0){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.a[pb][0].t&lt;0 in parse_amber_prmtop"</span>);}
00204                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pa][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>&gt;=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.a[pa][0].t&gt;=P[0].NTYPES in parse_amber_prmtop"</span>);}
00205                 }
00206 }
00207                 <span class="comment">// interactions.  See ICO below.  </span>
00208 <span class="comment">// FORMAT(12I6)  (NUMEX(i), i=1,NATOM)</span>
00209 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"NUMBER_EXCLUDED_ATOMS"</span>)==0){ <span class="comment">// unused for now (20080612)</span>
00210         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo48">NUMEX</a>  =pa; <span class="comment">// NUMEX  : total number of excluded atoms for atom "i".  See</span>
00211         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00212 }
00213                 <span class="comment">// NATEX below.  </span>
00214 <span class="comment">// FORMAT(12I6)  (ICO(i), i=1,NTYPES*NTYPES)</span>
00215 <span class="comment">// START HERE -- figure out how to put this is (efficiently...)</span>
00216 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"NONBONDED_PARM_INDEX"</span>)==0){ <span class="comment">// </span>
00217         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo49">ICO</a>    =pa; <span class="comment">// ICO    : provides the index to the nonbon parameter</span>
00218         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00219         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=nICO){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=nICO in parse_amber_prmtop."</span>);}
00220         <span class="keywordflow">for</span>(pb=0;pb&lt;nICO;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;ICO[pb]);}
00221                 <span class="comment">// arrays CN1, CN2 and ASOL, BSOL.  All possible 6-12</span>
00222                 <span class="comment">// or 10-12 atoms type interactions are represented.</span>
00223                 <span class="comment">// NOTE: A particular atom type can have either a 10-12</span>
00224                 <span class="comment">// or a 6-12 interaction, but not both.  The index is</span>
00225                 <span class="comment">// calculated as follows:</span>
00226                 <span class="comment">// index = ICO(NTYPES*(IAC(i)-1)+IAC(j))</span>
00227                 <span class="comment">// If index is positive, this is an index into the</span>
00228                 <span class="comment">// 6-12 parameter arrays (CN1 and CN2) otherwise it</span>
00229                 <span class="comment">// is an index into the 10-12 parameter arrays (ASOL and BSOL).  </span>
00230 }
00231 <span class="comment">// FORMAT(20A4)  (LABRES(i), i=1,NRES)</span>
00232 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RESIDUE_LABEL"</span>)==0){ <span class="comment">// names of residues</span>
00233         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo50">LABRES</a> =pa; <span class="comment">// LABRES : the residue labels </span>
00234         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00235         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.nr in RESIDUE_LABEL in parse_amber_prmtop"</span>);}
00236         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>;pb++){
00237                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>=(<span class="keywordtype">char</span>*)calloc((P[0].S[pa].nc+1),<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00238                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>);
00239                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>=(<span class="keywordtype">char</span>*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>,strlen(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>+1));
00240                 }
00241 }
00242 <span class="comment">// FORMAT(10a8)</span>
00243 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RESIDUE_ID"</span>)==0){<span class="comment">// ?? Presumably residue numbers, will store there</span>
00244         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo51">IRES</a> =pa; <span class="comment">// START HERE -- this is probably the wrong name!!!!!</span>
00245         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00246         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.nr in RESIDUE_ID in parse_amber_prmtop"</span>);}
00247         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo0">n</a>);}
00248 }
00249 <span class="comment">// FORMAT(12I6)  (IPRES(i), i=1,NRES)</span>
00250 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RESIDUE_POINTER"</span>)==0){ <span class="comment">// for adding atoms to residues</span>
00251         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo52">IPRES</a>  =pa; <span class="comment">// IPRES  : atoms in each residue are listed for atom "i" in</span>
00252         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00253         pc=0;
00254         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.nr in RESIDUE_POINTER in parse_amber_prmtop"</span>);}
00255 <span class="comment">//printf("A.nr is %d\n",A.nr);</span>
00256         <span class="keywordflow">for</span>(pb=0;pb&lt;(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo8">nr</a>-1);pb++){
00257 <span class="comment">//printf("pb is %d\n",pb);</span>
00258                 sscanf(P[0].S[pa].D[pb+1],<span class="stringliteral">"%d"</span>,&amp;NextRes);
00259 <span class="comment">//printf("NextRes is %d\n",NextRes);</span>
00260                 NextRes-=1;
00261                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>=NextRes-pc;
00262 <span class="comment">//printf("A.r[pb][0].na is %d\n",A.r[pb][0].na);</span>
00263                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>));
00264                 pd=0;
00265                 <span class="keywordflow">for</span>(pc=pc;pc&lt;NextRes;pc++){
00266 <span class="comment">//printf("pc is %d\n",pc);</span>
00267                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0]; <span class="comment">// copy atom into residue</span>
00268                         <span class="comment">//A.r[pb][0].a[NextRes-pc]=A.a[pc][0]; // copy atom into residue</span>
00269                         <span class="comment">//free(A.a[pc]); // free that memory</span>
00270                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc]=&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]; <span class="comment">// set atom pointer to new location</span>
00271                         <span class="comment">//A.a[pc]=&amp;A.r[pb][0].a[NextRes-pc]; // set atom pointer to new location</span>
00272                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>=pc+1; <span class="comment">// set the amber original number</span>
00273                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pc; <span class="comment">// set absolute atom number in array terms</span>
00274                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know this yet</span>
00275                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=pb; <span class="comment">// check this later</span>
00276                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pd; <span class="comment">// check this later</span>
00277                         <span class="comment">//MOLI[pc].a=NextRes-pc; // check this later</span>
00278                         pd++;
00279                         }
00280                 }
00281 <span class="comment">//printf("pb is %d\n",pb);</span>
00282                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>-pc;
00283 <span class="comment">//printf("A.r[pb][0].na is %d\n",A.r[pb][0].na);</span>
00284                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>));
00285                 pd=0;
00286                 <span class="keywordflow">for</span>(pc=pc;pc&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>;pc++){
00287 <span class="comment">//printf("pc is %d\t",pc);</span>
00288                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0]; <span class="comment">// copy atom into residue</span>
00289 <span class="comment">//printf("the name of atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.a[pc][0].N);</span>
00290 <span class="comment">//printf("\tthe charge of atom pc is &gt;&gt;&gt;%f&lt;&lt;&lt;\n",A.a[pc][0].ch[0]);</span>
00291 <span class="comment">//printf("the name of new atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.r[pb][0].a[pd].N);</span>
00292 <span class="comment">//printf("\tthe charge of new atom pc is &gt;&gt;&gt;%f&lt;&lt;&lt;\n",A.r[pb][0].a[pd].ch[0]);</span>
00293                         <span class="comment">//A.r[pb][0].a[NextRes-pc]=A.a[pc][0]; // copy atom into residue</span>
00294                         <span class="comment">//free(A.a[pc]); // free that memory</span>
00295 <span class="comment">//printf("\t***the name of new atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.r[pb][0].a[pd].N);</span>
00296 <span class="comment">//printf("\t***the charge of new atom pc is &gt;&gt;&gt;%f&lt;&lt;&lt;\n",A.r[pb][0].a[pd].ch[0]);</span>
00297 <span class="comment">//printf("xxxx the name of atom pc is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",A.a[pc][0].N);</span>
00298                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc]=&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pb][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pd]; <span class="comment">// set atom pointer to new location</span>
00299                         <span class="comment">//A.a[pc]=&amp;A.r[pb][0].a[NextRes-pc]; // set atom pointer to new location</span>
00300                         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pc][0].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>=pc+1; <span class="comment">// set the amber original number</span>
00301                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pc; <span class="comment">// set absolute atom number in array terms</span>
00302                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know this yet</span>
00303                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=pb; <span class="comment">// check this later</span>
00304                         MOLI[pc].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pd; <span class="comment">// check this later</span>
00305                         <span class="comment">//MOLI[pc].a=NextRes-pc; // check this later</span>
00306                         pd++;
00307                         }
00308 
00309         
00310 }
00311                 <span class="comment">// IPRES(i) to IPRES(i+1)-1 </span>
00312 <span class="comment">// FORMAT(5E16.8)  (RK(i), i=1,NUMBND)</span>
00313 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BOND_FORCE_CONSTANT"</span>)==0){ <span class="comment">// </span>
00314         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo53">RK</a>     =pa; <span class="comment">// RK     : force constant for the bonds of each type, kcal/mol </span>
00315         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00316 <span class="comment">//printf("pa is %d; this is BOND_FORCE_CONSTANT\n",pa);</span>
00317 <span class="comment">//printf("the number of bond types is %d\n",A.PRM[0].nBT);</span>
00318         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nBT in BOND_FORCE_CONSTANT in parse_amber_prmtop"</span>);}
00319         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>;pb++){
00320 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,pb,P[0].S[pa].D[pb]);</span>
00321                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto7">BT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo3">k</a>);
00322                 }
00323 }
00324 <span class="comment">// FORMAT(5E16.8)  (REQ(i), i=1,NUMBND)</span>
00325 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BOND_EQUIL_VALUE"</span>)==0){
00326         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo54">REQ</a>    =pa; <span class="comment">// REQ    : the equilibrium bond length for the bonds of each type, angstroms </span>
00327         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00328         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nBT in BOND_EQUIL_VALUE in parse_amber_prmtop"</span>);}
00329         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto6">nBT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto7">BT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo4">l</a>);}
00330 }
00331 <span class="comment">// FORMAT(5E16.8)  (TK(i), i=1,NUMANG)</span>
00332 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLE_FORCE_CONSTANT"</span>)==0){
00333         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo55">TK</a>     =pa; <span class="comment">// TK     : force constant for the angles of each type, kcal/mol A**2 </span>
00334         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00335         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nANT in ANGLE_FORCE_CONSTANT in parse_amber_prmtop"</span>);}
00336         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto13">ANT</a>[pb].<a class="code" href="../../dc/ddd/structangle__type.html#angle__typeo2">k</a>);}
00337 }
00338 <span class="comment">// FORMAT(5E16.8)  (TEQ(i), i=1,NUMANG)</span>
00339 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLE_EQUIL_VALUE"</span>)==0){
00340         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo56">TEQ</a>    =pa; <span class="comment">// TEQ    : the equilibrium angle for the angles of each type, radians </span>
00341         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00342         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nANT in ANGLE_EQUIL_VALUE in parse_amber_prmtop"</span>);}
00343         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto12">nANT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto13">ANT</a>[pb].<a class="code" href="../../dc/ddd/structangle__type.html#angle__typeo3">l</a>);}
00344 }
00345 <span class="comment">// FORMAT(5E16.8)  (PK(i), i=1,NPTRA)</span>
00346 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRAL_FORCE_CONSTANT"</span>)==0){
00347         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo57">PK</a>     =pa; <span class="comment">// PK     : force constant for the dihedrals of each type, kcal/mol </span>
00348         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00349         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nTRT in DIHEDRAL_FORCE_CONSTANT in parse_amber_prmtop"</span>);}
00350         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>;pb++){
00351                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>&gt;1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.PRM[0].TRT[pb].n&gt;1 in parse_amber_prmtop!"</span>);}
00352                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>=1;
00353                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo3">k</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00354                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo3">k</a>[0]);
00355                 }
00356 }
00357 <span class="comment">// FORMAT(5E16.8)  (PN(i), i=1,NPTRA)</span>
00358 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRAL_PERIODICITY"</span>)==0){
00359         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo58">PN</a>     =pa; <span class="comment">// PN     : periodicity of the dihedral of a given type </span>
00360         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00361         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nTRT in DIHEDRAL_PERIODICITY in parse_amber_prmtop"</span>);}
00362         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>;pb++){
00363                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>&gt;1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.PRM[0].TRT[pb].n&gt;1 in parse_amber_prmtop!"</span>);}
00364                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>=1;
00365                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo4">N</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00366                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo4">N</a>[0]);
00367                 }
00368 }
00369 <span class="comment">// FORMAT(5E16.8)  (PHASE(i), i=1,NPTRA)</span>
00370 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRAL_PHASE"</span>)==0){
00371         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo59">PHASE</a>  =pa; <span class="comment">// PHASE  : phase of the dihedral of a given type, radians </span>
00372         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00373         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.PRM[0].nTRT in DIHEDRAL_PHASE in parse_amber_prmtop"</span>);}
00374         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto14">nTRT</a>;pb++){
00375                 <span class="keywordflow">if</span>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>&gt;1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"A.PRM[0].TRT[pb].n&gt;1 in parse_amber_prmtop!"</span>);}
00376                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo2">n</a>=1;
00377                 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo5">P</a>=(<span class="keywordtype">double</span>*)calloc(1,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00378                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto15">TRT</a>[pb].<a class="code" href="../../da/d03/structtorsion__type.html#torsion__typeo5">P</a>[0]);
00379                 }
00380 }
00381 <span class="comment">// FORMAT(5E16.8)  (SOLTY(i), i=1,NATYP)</span>
00382 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"SOLTY"</span>)==0){ <span class="comment">// not much to do here at the moment</span>
00383         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo60">SOLTY</a>  =pa; <span class="comment">// SOLTY  : currently unused (reserved for future use) </span>
00384         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00385 }
00386 <span class="comment">// FORMAT(5E16.8)  (CN1(i), i=1,NTYPES*(NTYPES+1)/2)</span>
00387 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LENNARD_JONES_ACOEF"</span>)==0){
00388         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo61">CN1</a>    =pa; <span class="comment">// CN1    : Lennard Jones r**12 terms for all possible atom type</span>
00389         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00390         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>){
00391                 fprintf(stdout,<span class="stringliteral">"P[0].S[pa].nt (%d) !=A.PRM[0].nNBT (%d) in LENNARD_JONES_ACOEF in parse_amber_prmtop\n"</span>,P[0].S[pa].nt,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>);
00392                 <span class="comment">//mywhine("P[0].S[pa].nt!=A.PRM[0].nNBT in LENNARD_JONES_ACOEF in parse_amber_prmtop");</span>
00393                 } 
00394         <span class="comment">// record the LJ parameters to the bond type info</span>
00395         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>;pb++){ sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo11">LJ12_612</a>); }
00396                 <span class="comment">// interactions, indexed by ICO and IAC; for atom i and j</span>
00397                 <span class="comment">// where i &lt; j, the index into this array is as follows</span>
00398                 <span class="comment">// (assuming the value of ICO(index) is positive):</span>
00399                 <span class="comment">// CN1(ICO(NTYPES*(IAC(i)-1)+IAC(j))).  </span>
00400 }
00401 <span class="comment">// FORMAT(5E16.8)  (CN2(i), i=1,NTYPES*(NTYPES+1)/2)</span>
00402 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LENNARD_JONES_BCOEF"</span>)==0){
00403         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo62">CN2</a>    =pa; <span class="comment">// CN2    : Lennard Jones r**6 terms for all possible atom type</span>
00404         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00405         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>){
00406                 fprintf(stdout,<span class="stringliteral">"P[0].S[pa].nt (%d) !=A.PRM[0].nNBT (%d) in LENNARD_JONES_BCOEF in parse_amber_prmtop\n"</span>,P[0].S[pa].nt,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>);
00407                 <span class="comment">//mywhine("P[0].S[pa].nt!=A.PRM[0].nNBT in LENNARD_JONES_BCOEF in parse_amber_prmtop");</span>
00408                 }
00409         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto10">nNBT</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo10">LJ6_612</a>);}
00410                 <span class="comment">// interactions.  Indexed like CN1 above.  </span>
00411 }
00412 <span class="comment">/* NOTE: the atom numbers in the following arrays that describe bonds, </span>
00413 <span class="comment">        angles, and dihedrals are coordinate array indexes for runtime speed. </span>
00414 <span class="comment">        The true atom number equals the absolute value of the number divided by </span>
00415 <span class="comment">        three, plus one. In the case of the dihedrals, if the fourth atom is negative, </span>
00416 <span class="comment">        this implies that the dihedral is an improper. If the third atom is negative, </span>
00417 <span class="comment">        this implies that the end group interations are to be ignored. End group </span>
00418 <span class="comment">        interactions are ignored, for example, in dihedrals of various ring systems </span>
00419 <span class="comment">        (to prevent double counting of 1-4 interactions) and in multiterm dihedrals.  */</span>
00420 <span class="comment">// FORMAT(12I6)  (IBH(i),JBH(i),ICBH(i), i=1,NBONH)</span>
00421 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BONDS_INC_HYDROGEN"</span>)==0){
00422         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo63">IBH</a>    =pa; <span class="comment">// IBH    : atom involved in bond "i", bond contains hydrogen</span>
00423         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo64">JBH</a>    =pa; <span class="comment">// JBH    : atom involved in bond "i", bond contains hydrogen</span>
00424         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo65">ICBH</a>   =pa; <span class="comment">// ICBH   : index into parameter arrays RK and REQ </span>
00425         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00426         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=3*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].NBONH in BONDS_INC_HYDROGEN in parse_amber_prmtop"</span>);}
00427         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>;pb++){
00428                 <span class="comment">// read in the values from the section structure</span>
00429                 sscanf(P[0].S[pa].D[3*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00430                 sscanf(P[0].S[pa].D[3*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00431                 sscanf(P[0].S[pa].D[3*pb+2],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00432 <span class="comment">//printf("pA1 is %d ; pA2 is %d ; pI1 is %d \n",pA1,pA2,pI1);</span>
00433                 <span class="comment">// find the actual atom numbers</span>
00434                 pA1/=3;  <span class="comment">// CAREFUL !! these can be negative</span>
00435                 pA2/=3; 
00436                 <span class="comment">// set the bond info for these two atoms</span>
00437                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00438                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00439                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00440                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00441                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo5">D</a>=strdup(<span class="stringliteral">"BONDS_INC_HYDROGEN"</span>);
00442                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00443                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00444                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// </span>
00445                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA1; <span class="comment">// </span>
00446                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00447                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00448                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA2; 
00449                 MB[pb].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00450 <span class="comment">//printf("MB[pb].s.i is  %d ; MB[pb].t.i is %d ;  MB[%d].i is %d \n",MB[pb].s.i,MB[pb].t.i,pb,MB[pb].i);</span>
00451                 }
00452 }
00453 <span class="comment">// FORMAT(12I6)  (IB(i),JB(i),ICB(i), i=1,NBONA)</span>
00454 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BONDS_WITHOUT_HYDROGEN"</span>)==0){
00455         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo66">IB</a>     =pa; <span class="comment">// IB     : atom involved in bond "i", bond does not contain hydrogen</span>
00456         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo67">JB</a>     =pa; <span class="comment">// JB     : atom involved in bond "i", bond does not contain hydrogen</span>
00457         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo68">ICB</a>    =pa; <span class="comment">// ICB    : index into parameter arrays RK and REQ </span>
00458         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00459 <span class="comment">//printf("NBONH is %d ; MBONA is %d ; (sum : %d) and nb is A.nb=%d \n", P[0].NBONH,P[0].MBONA,P[0].MBONA+P[0].NBONH,A.nb);</span>
00460         <span class="comment">//for(pb=P[0].NBONH;pb&lt;(P[0].NBONH+P[0].MBONA);pb++) // save this line for use later...</span>
00461         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=3*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo17">MBONA</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].MBONA in BONDS_WITHOUT_HYDROGEN in parse_amber_prmtop"</span>);}
00462         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo17">MBONA</a>;pb++){ <span class="comment">// save this line for use later...</span>
00463 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,3*pb,P[0].S[pa].D[3*pb]);</span>
00464 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,3*pb+1,P[0].S[pa].D[3*pb+1]);</span>
00465 <span class="comment">//printf("P[0].S[%d].D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pa,3*pb+2,P[0].S[pa].D[3*pb+2]);</span>
00466                 <span class="comment">// read in the values from the section structure</span>
00467                 sscanf(P[0].S[pa].D[3*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00468                 sscanf(P[0].S[pa].D[3*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00469                 sscanf(P[0].S[pa].D[3*pb+2],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00470 <span class="comment">//printf("(non-H) pA1 is %d ; pA2 is %d ; pI1 is %d \n",pA1,pA2,pI1);</span>
00471                 <span class="comment">// find the actual atom numbers</span>
00472                 <span class="keywordflow">if</span>(pA1&lt;0) pA1*=-1;
00473                 <span class="keywordflow">if</span>(pA2&lt;0) pA2*=-1;
00474                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00475                 pA2/=3; 
00476                 <span class="comment">// set the bond info for these two atoms</span>
00477                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00478                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00479                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00480                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00481                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo5">D</a>=strdup(<span class="stringliteral">"BONDS_WITHOUT_HYDROGEN"</span>);
00482                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00483                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00484                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// the best atom number we have at the moment</span>
00485                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA1; <span class="comment">// for assigning molecules based on bonds, later</span>
00486                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00487                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00488                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00489                 MB[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo16">NBONH</a>].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>=pA2; 
00490 <span class="comment">//printf("(non-H) MB[pb].s.i is  %d ; MB[pb].t.i is %d ;  MB[%d].i is %d \n",MB[pb+P[0].NBONH].s.i,MB[pb+P[0].NBONH].t.i,pb+P[0].NBONH,MB[pb+P[0].NBONH].i);</span>
00491                 }
00492 }
00493 <span class="comment">// FORMAT(12I6)  (ITH(i),JTH(i),KTH(i),ICTH(i), i=1,NTHETH)</span>
00494 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLES_INC_HYDROGEN"</span>)==0){
00495         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo69">ITH</a>    =pa; <span class="comment">// ITH    : atom involved in angle "i", angle contains hydrogen</span>
00496         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo70">JTH</a>    =pa; <span class="comment">// JTH    : atom involved in angle "i", angle contains hydrogen</span>
00497         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo71">KTH</a>    =pa; <span class="comment">// KTH    : atom involved in angle "i", angle contains hydrogen</span>
00498         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo72">ICTH</a>   =pa; <span class="comment">// ICTH   : index into parameter arrays TK and TEQ for angle</span>
00499         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00500         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=4*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].NTHETH in ANGLES_INC_HYDROGEN in parse_amber_prmtop"</span>);}
00501         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>;pb++){ <span class="comment">// angles with hydrogen</span>
00502                 <span class="comment">// read in the values from the section structure</span>
00503                 sscanf(P[0].S[pa].D[4*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00504                 sscanf(P[0].S[pa].D[4*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00505                 sscanf(P[0].S[pa].D[4*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00506                 sscanf(P[0].S[pa].D[4*pb+3],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00507                 <span class="comment">// find the actual atom numbers</span>
00508                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00509                 pA2/=3; 
00510                 pA3/=3; 
00511                 <span class="comment">// set the bond info for these two atoms</span>
00512                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00513                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00514                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00515                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo6">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00516                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo5">D</a>=strdup(<span class="stringliteral">"ANGLES_INC_HYDROGEN"</span>);
00517                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00518                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00519                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are already read in</span>
00520                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00521                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1;
00522                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00523                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00524                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00525                 MANG[pb].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00526                 }
00527 }
00528                 <span class="comment">// ITH(i)-JTH(i)-KTH(i) </span>
00529 <span class="comment">// FORMAT(12I6)  (IT(i),JT(i),KT(i),ICT(i), i=1,NTHETA)</span>
00530 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ANGLES_WITHOUT_HYDROGEN"</span>)==0){
00531         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo73">IT</a>     =pa; <span class="comment">// IT     : atom involved in angle "i", angle does not contain hydrogen</span>
00532         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo74">JT</a>     =pa; <span class="comment">// JT     : atom involved in angle "i", angle does not contain hydrogen</span>
00533         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo75">KT</a>     =pa; <span class="comment">// KT     : atom involved in angle "i", angle does not contain hydrogen</span>
00534         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo76">ICT</a>    =pa; <span class="comment">// ICT    : index into parameter arrays TK and TEQ for angle</span>
00535         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00536         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=4*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo19">MTHETA</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].MTHETA in ANGLES_WITHOUT_HYDROGEN in parse_amber_prmtop"</span>);}
00537         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo19">MTHETA</a>;pb++){ <span class="comment">// angles without hydrogen</span>
00538                 <span class="comment">// read in the values from the section structure</span>
00539                 sscanf(P[0].S[pa].D[4*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00540                 sscanf(P[0].S[pa].D[4*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00541                 sscanf(P[0].S[pa].D[4*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00542                 sscanf(P[0].S[pa].D[4*pb+3],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00543                 <span class="comment">// find the actual atom numbers</span>
00544                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00545                 pA2/=3; 
00546                 pA3/=3; 
00547                 <span class="comment">// set the bond info for these two atoms</span>
00548                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00549                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00550                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00551                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo6">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00552                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo5">D</a>=strdup(<span class="stringliteral">"ANGLES_WITHOUT_HYDROGEN"</span>);
00553                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00554                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00555                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are read in already</span>
00556                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00557                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00558                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00559                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00560                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00561                 MANG[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo18">NTHETH</a>].<a class="code" href="../../da/d09/structangle__index.html#angle__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00562                 }
00563 }
00564                 <span class="comment">// IT(i)-JT(i)-KT(i) </span>
00565 <span class="comment">// FORMAT(12I6)  (IPH(i),JPH(i),KPH(i),LPH(i),ICPH(i), i=1,NPHIH)</span>
00566 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRALS_INC_HYDROGEN"</span>)==0){
00567         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo77">IPH</a>    =pa; <span class="comment">// IPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00568         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo78">JPH</a>    =pa; <span class="comment">// JPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00569         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo79">KPH</a>    =pa; <span class="comment">// KPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00570         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo80">LPH</a>    =pa; <span class="comment">// LPH    : atom involved in dihedral "i", dihedral contains hydrogen</span>
00571         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo81">ICPH</a>   =pa; <span class="comment">// ICPH   : index into parameter arrays PK, PN, and PHASE for</span>
00572         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00573         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=5*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].NPHIH in DIHEDRALS_INC_HYDROGEN in parse_amber_prmtop"</span>);}
00574         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>;pb++){ <span class="comment">// dihedrals with hydrogen</span>
00575                 <span class="comment">// read in the values from the section structure</span>
00576                 sscanf(P[0].S[pa].D[5*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00577                 sscanf(P[0].S[pa].D[5*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00578                 sscanf(P[0].S[pa].D[5*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00579                 sscanf(P[0].S[pa].D[5*pb+3],<span class="stringliteral">"%d"</span>,&amp;pA3);
00580                 sscanf(P[0].S[pa].D[5*pb+4],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00581                 <span class="comment">// find the actual atom numbers</span>
00582                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00583                 pA2/=3; 
00584                 pA3/=3; 
00585                 pA4/=3; 
00586                 <span class="comment">// set the bond info for these two atoms</span>
00587                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00588                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00589                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00590                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo7">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00591                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo6">D</a>=strdup(<span class="stringliteral">"DIHEDRALS_INC_HYDROGEN"</span>);
00592                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00593                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00594                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are read in already</span>
00595                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00596                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00597                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00598                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00599                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00600                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00601                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00602                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00603                 MTOR[pb].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA4; 
00604                 }
00605 }
00606                 <span class="comment">// dihedral IPH(i)-JPH(i)-KPH(i)-LPH(i) </span>
00607 <span class="comment">// FORMAT(12I6)  (IP(i),JP(i),KP(i),LP(i),ICP(i), i=1,NPHIA)</span>
00608 
00609 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"DIHEDRALS_WITHOUT_HYDROGEN"</span>)==0){
00610         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo82">IP</a>     =pa; <span class="comment">// IP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00611         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo83">JP</a>     =pa; <span class="comment">// JP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00612         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo84">KP</a>     =pa; <span class="comment">// KP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00613         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo85">LP</a>     =pa; <span class="comment">// LP     : atom involved in dihedral "i", dihedral does not contain hydrogen</span>
00614         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo86">ICP</a>    =pa; <span class="comment">// ICP    : index into parameter arrays PK, PN, and PHASE for</span>
00615         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00616         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=5*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo21">MPHIA</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=P[0].MPHIA in DIHEDRALS_WITHOUT_HYDROGEN in parse_amber_prmtop"</span>);}
00617         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo21">MPHIA</a>;pb++){ <span class="comment">// dihedrals with hydrogen</span>
00618                 <span class="comment">// read in the values from the section structure</span>
00619                 sscanf(P[0].S[pa].D[5*pb],<span class="stringliteral">"%d"</span>,&amp;pA1);
00620                 sscanf(P[0].S[pa].D[5*pb+1],<span class="stringliteral">"%d"</span>,&amp;pA2);
00621                 sscanf(P[0].S[pa].D[5*pb+2],<span class="stringliteral">"%d"</span>,&amp;pA3);
00622                 sscanf(P[0].S[pa].D[5*pb+3],<span class="stringliteral">"%d"</span>,&amp;pA3);
00623                 sscanf(P[0].S[pa].D[5*pb+4],<span class="stringliteral">"%d"</span>,&amp;pI1); 
00624                 <span class="comment">// find the actual atom numbers</span>
00625                 pA1/=3; <span class="comment">// CAREFUL !! these can be negative</span>
00626                 pA2/=3; 
00627                 pA3/=3; 
00628                 pA4/=3; 
00629                 <span class="comment">// set the bond info for these two atoms</span>
00630                 <span class="comment">// -- at this point, everything is in the same molecule, so the molecule index</span>
00631                 <span class="comment">//      will be set to -1 (to prevent confusion later).</span>
00632                 <span class="comment">//      Also, since we don't know the ordering in the file, most info will not be set</span>
00633                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo7">i</a>=pI1; <span class="comment">// holder for the index into the RK &amp; REQ arrays</span>
00634                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo6">D</a>=strdup(<span class="stringliteral">"DIHEDRALS_INC_HYDROGEN"</span>);
00635                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; <span class="comment">// we don't know the molecule number yet</span>
00636                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; <span class="comment">// we can't assume we know the residue number yet</span>
00637                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo0">a</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA1; <span class="comment">// we can't assume the atoms are read in already</span>
00638                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00639                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00640                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo1">b</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA2; 
00641                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00642                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00643                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo2">c</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA3; 
00644                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=-1; 
00645                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=-1; 
00646                 MTOR[pb+P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo20">NPHIH</a>].<a class="code" href="../../d2/d3d/structtorsion__index.html#torsion__indexo3">d</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=pA4; 
00647                 }
00648 }
00649 
00650                 <span class="comment">// dihedral IPH(i)-JPH(i)-KPH(i)-LPH(i).  Note, if the</span>
00651                 <span class="comment">// periodicity is negative, this implies the following entry</span>
00652                 <span class="comment">// in the PK, PN, and PHASE arrays is another term in a</span>
00653                 <span class="comment">// multitermed dihedral.  </span>
00654 <span class="comment">// FORMAT(12I6)  (NATEX(i), i=1,NEXT)</span>
00655 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"EXCLUDED_ATOMS_LIST"</span>)==0){
00656         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo87">NATEX</a>  =pa; <span class="comment">// NATEX  : the excluded atom list.  To get the excluded list for atom </span>
00657         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00658 }
00659                 <span class="comment">// "i" you need to traverse the NUMEX list, adding up all</span>
00660                 <span class="comment">// the previous NUMEX values, since NUMEX(i) holds the number</span>
00661                 <span class="comment">// of excluded atoms for atom "i", not the index into the </span>
00662                 <span class="comment">// NATEX list.  Let IEXCL = SUM(NUMEX(j), j=1,i-1), then</span>
00663                 <span class="comment">// excluded atoms are NATEX(IEXCL) to NATEX(IEXCL+NUMEX(i)).  </span>
00664 <span class="comment">// FORMAT(5E16.8)  (ASOL(i), i=1,NPHB)</span>
00665 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"HBOND_ACOEF"</span>)==0){
00666         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo88">ASOL</a>   =pa; <span class="comment">// ASOL   : the value for the r**12 term for hydrogen bonds of all</span>
00667         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00668 <span class="comment">//printf("A.PRM[0].nNBT is %d\n",A.PRM[0].nNBT);</span>
00669         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo33">NPHB</a>&gt;0){
00670         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>&gt;0){
00671         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo13">LJ12_1012</a>);}
00672         <span class="comment">//for(pb=0;pb&lt;A.PRM[0].nNBT;pb++){sscanf(P[0].S[pa].D[pb],"%lf",&amp;A.PRM[0].NBT[pb].LJ12_1012);}</span>
00673                 }
00674                 }
00675 }
00676                 <span class="comment">// possible types.  Index into these arrays is equivalent</span>
00677                 <span class="comment">// to the CN1 and CN2 arrays, however the index is negative.</span>
00678                 <span class="comment">// For example, for atoms i and j, with i &lt; j, the index is</span>
00679                 <span class="comment">// ICO(NTYPES*(IAC(i)-1+IAC(j)).  </span>
00680 <span class="comment">// FORMAT(5E16.8)  (BSOL(i), i=1,NPHB)</span>
00681 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"HBOND_BCOEF"</span>)==0){
00682         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo89">BSOL</a>   =pa; <span class="comment">// BSOL   : the value for the r**10 term for hydrogen bonds of all</span>
00683         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00684         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo33">NPHB</a>&gt;0){
00685         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>&gt;0){
00686                 <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[pb].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo12">LJ10_1012</a>);}
00687                 <span class="comment">//for(pb=0;pb&lt;A.PRM[0].nNBT;pb++){sscanf(P[0].S[pa].D[pb],"%lf",&amp;A.PRM[0].NBT[pb].LJ10_1012);}</span>
00688                 }
00689                 }
00690 }
00691                 <span class="comment">// possible types.  Indexed like ASOL.  </span>
00692 <span class="comment">// FORMAT(5E16.8)  (HBCUT(i), i=1,NPHB)</span>
00693 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"HBCUT"</span>)==0){
00694         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo90">HBCUT</a>  =pa; <span class="comment">// HBCUT  : no longer in use </span>
00695         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00696 }
00697 <span class="comment">// FORMAT(20A4)  (ISYMBL(i), i=1,NATOM)</span>
00698 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"AMBER_ATOM_TYPE"</span>)==0){
00699         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo91">ISYMBL</a> =pa; <span class="comment">// ISYMBL : the AMBER atom types for each atom </span>
00700         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00701         <span class="comment">// Can't assume we've already read in the type numbers...</span>
00702         <span class="comment">// read one per each atom, just like it is in the file</span>
00703         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in AMBER_ATOM_TYPE in parse_amber_prmtop"</span>);}
00704         ATNAME=(<span class="keywordtype">char</span>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00705         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00706                 ATNAME[pb]=(<span class="keywordtype">char</span>*)calloc(P[0].S[pa].nc+1,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00707                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,ATNAME[pb]);
00708                 }
00709 }
00710 <span class="comment">// FORMAT(20A4)  (ITREE(i), i=1,NATOM)</span>
00711 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"TREE_CHAIN_CLASSIFICATION"</span>)==0){
00712         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo92">ITREE</a>  =pa; <span class="comment">// ITREE  : the list of tree joining information, classified into five</span>
00713         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00714         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in TREE_CHAIN_CLASSIFICATION in parse_amber_prmtop"</span>);}
00715         TREECLASS=(<span class="keywordtype">char</span>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00716         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){
00717                 TREECLASS[pb]=(<span class="keywordtype">char</span>*)calloc(P[0].S[pa].nc+1,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00718                 sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%s"</span>,TREECLASS[pb]);
00719                 }
00720 }
00721                 <span class="comment">// types.  M -- main chain, S -- side chain, B -- branch point, </span>
00722                 <span class="comment">// 3 -- branch into three chains, E -- end of the chain </span>
00723 <span class="comment">// FORMAT(12I6)  (JOIN(i), i=1,NATOM)</span>
00724 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"JOIN_ARRAY"</span>)==0){
00725         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo93">JOIN</a>   =pa; <span class="comment">// JOIN   : tree joining information, potentially used in ancient</span>
00726                 <span class="comment">// analysis programs.  Currently unused in sander or gibbs.  </span>
00727         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00728 }
00729 <span class="comment">// FORMAT(12I6)  (IROTAT(i), i = 1, NATOM)</span>
00730 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"IROTAT"</span>)==0){
00731         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo94">IROTAT</a> =pa; <span class="comment">// IROTAT : apparently the last atom that would move if atom i was</span>
00732                 <span class="comment">// rotated, however the meaning has been lost over time.</span>
00733                 <span class="comment">// Currently unused in sander or gibbs.</span>
00734         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00735 }
00736 <span class="comment">// FORMAT(12I6)  IPTRES, NSPM, NSPSOL</span>
00737 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"SOLVENT_POINTERS"</span>)==0){
00738         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo95">IPTRES</a> =pa; <span class="comment">// IPTRES : final residue that is considered part of the solute,</span>
00739                 <span class="comment">// reset in sander and gibbs</span>
00740         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo96">NSPM</a>   =pa; <span class="comment">// NSPM   : total number of molecules</span>
00741         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo97">NSPSOL</a> =pa; <span class="comment">// NSPSOL : the first solvent "molecule" </span>
00742         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00743         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>==3){
00744                 sscanf(P[0].S[pa].D[0],<span class="stringliteral">"%d"</span>,&amp;IPTRES);
00745                 sscanf(P[0].S[pa].D[1],<span class="stringliteral">"%d"</span>,&amp;NSPM);
00746                 sscanf(P[0].S[pa].D[2],<span class="stringliteral">"%d"</span>,&amp;NSPSOL);
00747                 }
00748 }
00749 <span class="comment">// FORMAT(12I6)  (NSP(i), i=1,NSPM)</span>
00750 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ATOMS_PER_MOLECULE"</span>)==0){
00751         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo98">NSP</a>    =pa; <span class="comment">// NSP    : the total number of atoms in each molecule,</span>
00752                 <span class="comment">// necessary to correctly perform the pressure scaling.  </span>
00753         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00754         NSP=(<span class="keywordtype">int</span>*)calloc(P[0].S[pa].nt,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00755         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%d"</span>,&amp;NSP[pb]);}
00756 }
00757 <span class="comment">// FORMAT(5E16.8)  BETA, BOX(1), BOX(2), BOX(3)</span>
00758 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"BOX_DIMENSIONS"</span>)==0){
00759         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo99">BETA</a>   =pa; <span class="comment">// BETA   : periodic box, angle between the XY and YZ planes in degrees.</span>
00760         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo100">BOX</a>    =pa; <span class="comment">// BOX    : the periodic box lengths in the X, Y, and Z directions </span>
00761         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00762         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>==4){
00763                 sscanf(P[0].S[pa].D[0],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo26">boxang</a>);
00764                 sscanf(P[0].S[pa].D[1],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo24">boxl</a>.<a class="code" href="../../d8/d31/structcoord__3D.html#coord__3Do0">i</a>);
00765                 sscanf(P[0].S[pa].D[2],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo24">boxl</a>.<a class="code" href="../../d8/d31/structcoord__3D.html#coord__3Do1">j</a>);
00766                 sscanf(P[0].S[pa].D[3],<span class="stringliteral">"%lf"</span>,&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo24">boxl</a>.<a class="code" href="../../d8/d31/structcoord__3D.html#coord__3Do2">k</a>);
00767                 }
00768 }
00769 <span class="comment">// The following are only present if IFCAP .gt. 0 </span>
00770 <span class="comment">// FORMAT(12I6)  NATCAP</span>
00771 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"CAP_INFO"</span>)==0){
00772         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo101">NATCAP</a> =pa; <span class="comment">// NATCAP : last atom before the start of the cap of waters placed by edit </span>
00773         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00774 }
00775 <span class="comment">// FORMAT(5E16.8)  CUTCAP, XCAP, YCAP, ZCAP</span>
00776 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"CAP_INFO2"</span>)==0){ <span class="comment">// not putting this in quite yet</span>
00777         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo102">CUTCAP</a> =pa; <span class="comment">// CUTCAP : the distance from the center of the cap to the outside</span>
00778         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo103">XCAP</a>   =pa; <span class="comment">// XCAP   : X coordinate for the center of the cap</span>
00779         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo104">YCAP</a>   =pa; <span class="comment">// YCAP   : Y coordinate for the center of the cap</span>
00780         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo105">ZCAP</a>   =pa; <span class="comment">// ZCAP   : Z coordinate for the center of the cap </span>
00781         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00782 }
00783 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RADIUS_SET"</span>)==0){
00784         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00785         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>&gt;0){RADTYPE=strdup(P[0].S[pa].D[0]);}
00786 }
00787 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"RADII"</span>)==0){
00788         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00789         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in RADII in parse_amber_prmtop."</span>);}
00790         R=(<span class="keywordtype">double</span>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00791         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;R[pb]);}
00792 }
00793 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"SCREEN"</span>)==0){
00794         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00795         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>!=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"P[0].S[pa].nt!=A.na in SCREEN in parse_amber_prmtop."</span>);}
00796         SC=(<span class="keywordtype">double</span>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00797         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pb++){sscanf(P[0].S[pa].D[pb],<span class="stringliteral">"%lf"</span>,&amp;SC[pb]);}
00798 }
00799 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_NTYP"</span>)==0){ <span class="comment">// leave these out for now</span>
00800         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00801 }
00802 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_TYPE"</span>)==0){
00803         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00804 }
00805 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_FAC"</span>)==0){
00806         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00807 }
00808 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_CNUM"</span>)==0){
00809         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00810 }
00811 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"LES_ID"</span>)==0){
00812         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00813 }
00814 <span class="comment">// The following is only present if IFPERT .gt. 0</span>
00815 <span class="comment">/* Note that the initial state, or equivalently the prep/link/edit state, </span>
00816 <span class="comment">        is represented by lambda=1 and the perturbed state, or final state </span>
00817 <span class="comment">        specified in parm, is the lambda=0 state. */</span> 
00818 <span class="comment">// FORMAT(12I6)  (IBPER(i), JBPER(i), i=1,NBPER)</span>
00819 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_BOND_ATOMS"</span>)==0){
00820 <span class="comment">// The following are only present if IFBOX .gt. 0 </span>
00821         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo106">IBPER</a>  =pa; <span class="comment">// IBPER  : atoms involved in perturbed bonds</span>
00822         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo107">JBPER</a>  =pa; <span class="comment">// JBPER  : atoms involved in perturbed bonds </span>
00823         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00824 }
00825 <span class="comment">// FORMAT(12I6)  (ICBPER(i), i=1,2*NBPER)</span>
00826 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_BOND_PARAMS"</span>)==0){
00827         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo108">ICBPER</a> =pa; <span class="comment">// ICBPER : pointer into the bond parameter arrays RK and REQ for the</span>
00828         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00829 }
00830                 <span class="comment">// perturbed bonds.  ICBPER(i) represents lambda=1 and </span>
00831                 <span class="comment">// ICBPER(i+NBPER) represents lambda=0.  </span>
00832 <span class="comment">// FORMAT(12I6)  (ITPER(i), JTPER(i), KTPER(i), i=1,NGPER)</span>
00833 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ANGLE_ATOMS"</span>)==0){
00834         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo109">IPTER</a>  =pa; <span class="comment">// IPTER  : atoms involved in perturbed angles</span>
00835         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo110">JTPER</a>  =pa; <span class="comment">// JTPER  : atoms involved in perturbed angles</span>
00836         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo111">KTPER</a>  =pa; <span class="comment">// KTPER  : atoms involved in perturbed angles </span>
00837         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00838 }
00839 <span class="comment">// FORMAT(12I6)  (ICTPER(i), i=1,2*NGPER)</span>
00840 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ANGLE_PARAMS"</span>)==0){
00841         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo112">ICTPER</a> =pa; <span class="comment">// ICTPER : pointer into the angle parameter arrays TK and TEQ for </span>
00842         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00843 }
00844                 <span class="comment">// the perturbed angles.  ICTPER(i) represents lambda=0 and </span>
00845                 <span class="comment">// ICTPER(i+NGPER) represents lambda=1.  </span>
00846 <span class="comment">// FORMAT(12I6)  (IPPER(i), JPPER(i), KPPER(i), LPPER(i), i=1,NDPER)</span>
00847 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_DIHEDRAL_ATOMS"</span>)==0){
00848         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo113">IPPER</a>  =pa; <span class="comment">// IPPER  : atoms involved in perturbed dihedrals</span>
00849         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo114">JPPER</a>  =pa; <span class="comment">// JPPER  : atoms involved in perturbed dihedrals</span>
00850         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo115">KPPER</a>  =pa; <span class="comment">// KPPER  : atoms involved in perturbed dihedrals</span>
00851         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo116">LPPER</a>  =pa; <span class="comment">// LPPER  : atoms involved in pertrubed dihedrals </span>
00852         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00853 }
00854 <span class="comment">// FORMAT(12I6)  (ICPPER(i), i=1,2*NDPER)</span>
00855 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_DIHEDRAL_PARAMS"</span>)==0){
00856         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo117">ICPPER</a> =pa; <span class="comment">// ICPPER : pointer into the dihedral parameter arrays PK, PN and</span>
00857         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00858 }
00859                 <span class="comment">// PHASE for the perturbed dihedrals.  ICPPER(i) represents </span>
00860                 <span class="comment">// lambda=1 and ICPPER(i+NGPER) represents lambda=0.  </span>
00861 <span class="comment">// FORMAT(20A4)  (LABRES(i), i=1,NRES)</span>
00862 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_RESIDUE_NAME"</span>)==0){
00863         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo50">LABRES</a> =pa; <span class="comment">// LABRES : residue names at lambda=0 </span>
00864         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00865 }
00866 <span class="comment">// FORMAT(20A4)  (IGRPER(i), i=1,NATOM)</span>
00867 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ATOM_NAME"</span>)==0){
00868         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo119">IGRPER</a> =pa; <span class="comment">// IGRPER : atomic names at lambda=0 </span>
00869         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00870 }
00871 <span class="comment">// FORMAT(20A4)  (ISMPER(i), i=1,NATOM)</span>
00872 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ATOM_SYMBOL"</span>)==0){
00873         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo120">ISMPER</a> =pa; <span class="comment">// ISMPER : atomic symbols at lambda=0 </span>
00874         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00875 }
00876 <span class="comment">// FORMAT(5E16.8)  (ALMPER(i), i=1,NATOM)</span>
00877 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"ALMPER"</span>)==0){
00878         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo121">ALMPER</a> =pa; <span class="comment">// ALMPER : unused currently in gibbs </span>
00879         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00880 }
00881 <span class="comment">// FORMAT(12I6)  (IAPER(i), i=1,NATOM)</span>
00882 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"IAPER"</span>)==0){
00883         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo122">IAPER</a>  =pa; <span class="comment">// IAPER  : IAPER(i) = 1 if the atom is being perturbed </span>
00884         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00885 }
00886 <span class="comment">// FORMAT(12I6)  (IACPER(i), i=1,NATOM)</span>
00887 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_ATOM_TYPE_INDEX"</span>)==0){
00888         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo123">IACPER</a> =pa; <span class="comment">// IACPER : index for the atom types involved in Lennard Jones</span>
00889         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00890 }
00891                 <span class="comment">// interactions at lambda=0.  Similar to IAC above.  See ICO above.  </span>
00892 <span class="comment">// FORMAT(5E16.8)  (CGPER(i), i=1,NATOM)</span>
00893 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_CHARGE"</span>)==0){
00894         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo124">CGPER</a>  =pa; <span class="comment">// CGPER  : atomic charges at lambda=0 </span>
00895         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00896 }
00897 <span class="comment">// The following is only present if IPOL .eq. 1 </span>
00898 <span class="comment">// FORMAT(5E18.8) (ATPOL(i), i=1,NATOM)</span>
00899 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"POLARIZABILITY"</span>)==0){ <span class="comment">// leave out for now</span>
00900         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo125">ATPOL</a>  =pa; <span class="comment">// ATPOL  : atomic polarizabilities </span>
00901         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00902 }
00903 <span class="comment">// The following is only present if IPOL .eq. 1 .and. IFPERT .eq. 1 </span>
00904 <span class="comment">// FORMAT(5E18.8) (ATPOL1(i), i=1,NATOM)</span>
00905 <span class="keywordflow">if</span>(strcmp(P[0].S[pa].N,<span class="stringliteral">"PERT_POLARIZABILITY"</span>)==0){
00906         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo126">ATPOL1</a> =pa; <span class="comment">// ATPOL1 : atomic polarizabilities at lambda = 1 (above is at lambda = 0) </span>
00907         P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono4">is_standard</a>=0; <span class="comment">// set as a standard section</span>
00908 }
00909         } <span class="comment">// close loop through each section in the prmtop structure</span>
00910 
00911 F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>=<a class="code" href="../../df/da0/group__FILE__UTILS.html#ga0">myfopen</a>(<span class="stringliteral">"test_rewrite_of_prmtop"</span>,<span class="stringliteral">"w"</span>);
00912 fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%s"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo1">VERSION</a>);
00913 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo2">nS</a>;pa++){ <span class="comment">// for each section found</span>
00914         fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%%FLAG %s\n"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono0">N</a>);
00915         fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%%FORMAT(%s)\n"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono1">FORMAT</a>);
00916         <span class="keywordflow">for</span>(pb=0;pb&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>;pb++){
00917                 fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"%s"</span>,P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono10">D</a>[pb]);
00918                 <span class="comment">//fprintf(F.F,"D[%d] is &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pb,P[0].S[pa].D[pb]);</span>
00919                 fflush(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>);
00920 <span class="comment">//printf("\npb is %d ; P[0].S[%d].npl is %d ; (pb+1)%%npl is %d\n",pb,pa,P[0].S[pa].npl,);</span>
00921                 <span class="keywordflow">if</span>((((pb+1)%P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono6">npl</a>))==0){fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"\n"</span>);} 
00922                 <span class="comment">//if((((pb+1)*P[0].S[pa].nc))%80==0){printf("\n");} </span>
00923                 }
00924         <span class="keywordflow">if</span>(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono7">nt</a>==0){fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"\n"</span>);}
00925         <span class="keywordflow">if</span>(((pb)*P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo4">S</a>[pa].<a class="code" href="../../d6/d75/structamber__prmtop__section.html#amber__prmtop__sectiono5">nc</a>)%80!=0){fprintf(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>,<span class="stringliteral">"\n"</span>);} 
00926         }
00927 fclose(F.<a class="code" href="../../dc/d59/structfileset.html#fileseto1">F</a>);
00928 
00929 <span class="comment">// Set the names of the atom types in the type array</span>
00930 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo11">na</a>;pa++){ A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo12">a</a>[pa][0].<a class="code" href="../../da/d81/structatom.html#atomo4">t</a>].<a class="code" href="../../dc/d7a/structatype.html#atypeo1">N</a>=strdup(ATNAME[pa]); }
00931 <span class="comment">// Now set the names in the non-bonded bond type array</span>
00932 <span class="comment">// -- set atom information in the LJ type arrays</span>
00933 <span class="comment">//int *ICO,nICO;</span>
00934 <span class="keywordflow">if</span>(nICO!=(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>*A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>)){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"nICO!=(A.PRM[0].nAT*A.PRM[0].nAT) in parse_amber_prmtop"</span>);}
00935 <span class="comment">// For example, for atoms i and j, with i &lt; j, the index is</span>
00936 <span class="comment">// ICO(NTYPES*(IAC(i)-1)+IAC(j)).  </span>
00937 pI1=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>*(P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>+1)/2;
00938 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto0">nAT</a>;pa++){ <span class="comment">// this is index 'j' in the prmtop file</span>
00939 <span class="keywordflow">for</span>(pb=0;pb&lt;(pa+1);pb++){ <span class="comment">// this is index 'i' in the prmtop file</span>
00940         <span class="comment">// allocate space for the names of the two atom types</span>
00941         pc=P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo15">NTYPES</a>*pb+pa;
00942         <span class="keywordflow">if</span>(pc&gt;nICO){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"pc&gt;nICO in parse_amber_prmtop"</span>);}
00943         <span class="keywordflow">if</span>(ICO[pc]&gt;pI1){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"ICO[pc]&gt;(P[0].NTYPES*(P[0].NTYPES+1)/2) in parse_amber_prmtop"</span>);}
00944         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[ICO[pc]].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo0">NT</a>=(<span class="keywordtype">char</span>**)calloc(2,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00945         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[ICO[pc]].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo0">NT</a>[0]=strdup(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>[pb].<a class="code" href="../../dc/d7a/structatype.html#atypeo1">N</a>);
00946         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto11">NBT</a>[ICO[pc]].<a class="code" href="../../d6/def/structbond__type.html#bond__typeo0">NT</a>[1]=strdup(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo21">PRM</a>[0].<a class="code" href="../../db/d68/structparameter__set.html#parameter__seto1">AT</a>[pa].<a class="code" href="../../dc/d7a/structatype.html#atypeo1">N</a>);
00947         }
00948 }
00949 
00950 <span class="comment">// set molecule information</span>
00951 <span class="comment">//      First, copy MOLI &amp; MB arrays for safety &amp; record</span>
00952 MOLBNDI=(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>*)calloc(P[0].NATOM,<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4f/structmolindex.html">molindex</a>));
00953 MBTMP=(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>*)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../df/d7e/structmolbond.html">molbond</a>));
00954 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>;pa++){ MOLBNDI[pa]=MOLI[pa]; }
00955 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>;pa++){ 
00956         MBTMP[pa]=MB[pa]; 
00957 <span class="comment">//printf("MBTMP[%d].s.i is %d ; MBTMP[%d].t.i is %d \n",pa,MBTMP[pa].s.i,pa,MBTMP[pa].t.i);</span>
00958 <span class="comment">//printf("MB[%d].s.i is %d ; MB[%d].t.i is %d \n",pa,MB[pa].s.i,pa,MB[pa].t.i);</span>
00959         }
00960 <span class="comment">// call the "find molecules" function</span>
00961 <a class="code" href="../../d2/d2a/find__molecules_8c.html#a1">find_molecules_molbond_array</a>(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>, MBTMP, P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>, MOLBNDI);
00962 
00963 <span class="comment">// Rearrange the structures to reflect the new molecule information</span>
00964 <span class="comment">// 1. Find numbers of molecules and make space</span>
00965 <span class="comment">//      The molecules, coming from find_molecules_molbond_array, should count </span>
00966 <span class="comment">//      sequentially starting with zero.</span>
00967 <span class="comment">// 2. While we're at it, associate each residue with a molecule in a convenient array (resi)</span>
00968 nummol=0;
00969 resi=(<span class="keywordtype">int</span>*)calloc(P[0].NRES,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00970 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo25">NRES</a>;pa++){ resi[pa]=-1; }
00971 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo14">NATOM</a>;pa++){ 
00972         <span class="keywordflow">if</span>(MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>&gt;nummol){ nummol = MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>; }  <span class="comment">// find numbers of molecules</span>
00973         <span class="keywordflow">if</span>(resi[MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>]==-1) resi[MOLBNDI[pa].r]=MOLBNDI[pa].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
00974         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(resi[MOLBNDI[pa].r]!=MOLBNDI[pa].m){<a class="code" href="../../d9/d66/mywhine_8c.html#a0">mywhine</a>(<span class="stringliteral">"resi[MOLBNDI[pa].r]!=MOLBNDI[pa].m in parse_amber_prmtop"</span>);} 
00975 <span class="comment">//printf("pa is %d ; MOLBNDI[pa].r is %d . . . resi[MOLBNDI[pa].r] ===  %d\n",pa,MOLBNDI[pa].r,resi[MOLBNDI[pa].r]);</span>
00976         }
00977 nummol++;
00978 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>=nummol; <span class="comment">// make space for the molecules</span>
00979 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>=(<a class="code" href="../../dc/d7f/structmolecule.html">molecule</a>**)calloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>,<span class="keyword">sizeof</span>(<a class="code" href="../../dc/d7f/structmolecule.html">molecule</a>*));
00980 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>;pa++){ 
00981         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa]=(molecule*)calloc(1,<span class="keyword">sizeof</span>(molecule)); 
00982         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo8">na</a>=0;
00983         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>=0;
00984         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo9">a</a>=(<a class="code" href="../../da/d81/structatom.html">atom</a>**)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../da/d81/structatom.html">atom</a>*));
00985         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*)calloc(1,<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>));
00986         }
00987 <span class="comment">// place residues into molecule structures -- and do a little housekeeping</span>
00988 <span class="keywordflow">for</span>(pa=0;pa&lt;P[0].<a class="code" href="../../de/de7/structamber__prmtop.html#amber__prmtopo25">NRES</a>;pa++){
00989         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo0">n</a>=pa+1; <span class="comment">// the file-print residue "number"</span>
00990         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>++;
00991         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>=(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7e/structresidue.html">residue</a>));
00992         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>-1]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0]; <span class="comment">// copy over residue </span>
00993         <span class="comment">//free(A.r[pa]); // free space</span>
00994         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa]=&amp;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>-1];<span class="comment">// reassign pointer</span>
00995 <span class="comment">//printf("A.r[pa][0].na is %d\n",A.r[pa][0].na);</span>
00996         <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>;pb++){
00997 <span class="comment">//printf("\tA.r[%d][0].a[%d].n is %d  ;  MOLBNDI[A.r[pa][0].a[pb].n-1].r is %d \n",pa,pb,A.r[pa][0].a[pb].n,MOLBNDI[A.r[pa][0].a[pb].n-1].r); </span>
00998                 MOLBNDI[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo9">r</a>[pa][0].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pb].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>-1].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[resi[pa]][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>-1;
00999 <span class="comment">//printf("\t\t MOLBNDI[A.r[pa][0].a[pb].n-1].r is %d \n",MOLBNDI[A.r[pa][0].a[pb].n-1].r);</span>
01000                 }
01001 <span class="comment">//printf("Residue index %d has name &gt;&gt;&gt;%s&lt;&lt;&lt; (A.r[pa][0].N) or &gt;&gt;&gt;%s&lt;&lt;&lt; (thru the mol)\n",pa,A.r[pa][0].N,A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].N);</span>
01003 <span class="comment"></span><span class="comment">//printf("\t na is %d \n",A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].na); </span>
01004 <span class="comment">//for(pb=0;pb&lt;A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].na;pb++){</span>
01005 <span class="comment">//printf("\tAtom #%d is named &gt;&gt;&gt;%s&lt;&lt;&lt;\n",pb,A.m[resi[pa]][0].r[A.m[resi[pa]][0].nr-1].a[pb].N);</span>
01006 <span class="comment">//}</span>
01007         }
01008 
01009 
01010 <span class="comment">//for(pa=0;pa&lt;A.nm;pa++){</span>
01011 <span class="comment">//printf("============== there are %d molecules =================\n",A.nm);</span>
01012 <span class="comment">//dprint_molecule(A.m[pa],1000);}</span>
01013 
01014 <span class="comment">// if the NSPM &amp; NSP information is present, check results for consistency</span>
01015 <span class="comment">// NSPM = number of molecules</span>
01016 <span class="comment">// *NSP = number of atoms in each molecule</span>
01017 <span class="comment">// IPTRES = last residue that is solute</span>
01018 <span class="comment">// NSPSOL = first solvent residue</span>
01019 <span class="comment">//</span>
01020 <span class="comment">// Use new molecule information to reset residue numbers and molecule affiliations</span>
01021 <span class="comment">//      set the MOLI indices, too...</span>
01022 <span class="comment">//</span>
01023 <span class="comment">// START HERE -- when the above is finished, rewrite the following....</span>
01024 <span class="comment">// Set the bond information at the atom level</span>
01025 
01026 printf(<span class="stringliteral">"============== there are %d molecules =================\n"</span>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>);
01027 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>;pa++){
01028 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo1">N</a>=strdup(<span class="stringliteral">"unknown"</span>);
01029 A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo2">D</a>=strdup(<span class="stringliteral">"Molecule determined by read of Amber prmtop file"</span>);
01030 <span class="comment">//printf("\tMolecule %d contains %d residues\n",pa,A.m[pa][0].nr);</span>
01031 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>;pb++){
01032 <span class="comment">//printf("\t\tResidue %d contains %d atoms\n",pb,A.m[pa][0].r[pb].na);</span>
01033 <span class="keywordflow">for</span>(pc=0;pc&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>;pc++){
01034         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>=(molbond*)calloc(1,<span class="keyword">sizeof</span>(molbond)); 
01035 <span class="comment">//printf("Atom %s (# %d) belongs to residue # %d and molecule # %d\n",A.m[pa][0].r[pb].a[pc].N,pc,pb,pa);</span>
01036         }
01037         }
01038         }
01039 <span class="comment">//for(pa=0;pa&lt;A.na;pa++){</span>
01040 <span class="comment">//printf("MOLBNDI[pa=%d] i is %d ; m is %d ; r is %d ; a is %d\n",pa,MOLBNDI[pa].i,MOLBNDI[pa].m,MOLBNDI[pa].r,MOLBNDI[pa].a);</span>
01041 <span class="comment">//if(pa&gt;150) exit(0);</span>
01042 <span class="comment">//}</span>
01043 
01044 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo14">nb</a>;pa++){
01045         <span class="comment">// set global bonds</span>
01046         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>=MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo4">i</a>;
01047         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo5">D</a>=strdup(MBTMP[pa].D);
01048         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=sm=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01049         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=sr=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01050         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=sa=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01051         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>=tm=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01052         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>=tr=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01053         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>=ta=MOLBNDI[MBTMP[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo0">i</a>].<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01054 <span class="comment">/*</span>
01055 <span class="comment">printf("bond number, pa=%d \n",pa);</span>
01056 <span class="comment">printf("  MBTMP[pa].s.i is %d \n",MBTMP[pa].s.i);</span>
01057 <span class="comment">printf("    MBTMP[pa].t.i is %d\n",MBTMP[pa].t.i);</span>
01058 <span class="comment">printf("\tMOLBNDI[(s)].m =%d \n",MOLBNDI[MBTMP[pa].s.i].m);</span>
01059 <span class="comment">printf("\t\t .r=%d \n",MOLBNDI[MBTMP[pa].s.i].r);</span>
01060 <span class="comment">printf("\t\t    .a=%d\n",MOLBNDI[MBTMP[pa].s.i].a);</span>
01061 <span class="comment">printf("\t\tMOLBNDI[(t)].m =%d \n",MOLBNDI[MBTMP[pa].t.i].m);</span>
01062 <span class="comment">printf("\t\t\t  .r=%d \n",MOLBNDI[MBTMP[pa].t.i].r);</span>
01063 <span class="comment">printf("\t\t\t    .a=%d\n",MOLBNDI[MBTMP[pa].t.i].a);</span>
01064 <span class="comment">*/</span>
01065         <span class="comment">// -- set local bonds to molbond structure (later to local bond structure)</span>
01066         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>++;
01067         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>++;
01068         <span class="comment">// START HERE -- make sure these are allocated somewhere first.....</span>
01069         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>=(molbond*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>*<span class="keyword">sizeof</span>(molbond));
01070         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>=(molbond*)realloc(A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>*<span class="keyword">sizeof</span>(molbond));
01071         <span class="comment">// set both atoms as being bonded to the other</span>
01072         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[sm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[sr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[sa].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1]=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa]; <span class="comment">// if already "source", all is ok</span>
01073         <span class="comment">// if the atom is a "target", we have to turn things around a bit</span>
01074         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01075         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01076         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01077         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a> ;
01078         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a> ;
01079         A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>-1].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a> = A.<a class="code" href="../../db/dac/structassembly.html#assemblyo15">b</a>[pa].<a class="code" href="../../df/d7e/structmolbond.html#molbondo0">s</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a> ;
01080         }
01081 
01082 <span class="keywordflow">for</span>(pa=0;pa&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo5">nm</a>;pa++){
01083 printf(<span class="stringliteral">"MOLECULE #%d\n"</span>,pa);
01084 <span class="keywordflow">for</span>(pb=0;pb&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo11">nr</a>;pb++){
01085 printf(<span class="stringliteral">"\tRESIDUE #%d (name %s)\n"</span>,pb,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo1">N</a>); 
01086 <span class="keywordflow">for</span>(pc=0;pc&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo6">na</a>;pc++){
01087 printf(<span class="stringliteral">"\t\tATOM #%d (name %s) has %d bonds\n"</span>,pc,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>); 
01088 <span class="keywordflow">for</span>(pd=0;pd&lt;A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo9">nmb</a>;pd++){
01089 tm=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[pd].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo1">m</a>;
01090 tr=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[pd].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo2">r</a>;
01091 ta=A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[pa][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[pb].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[pc].<a class="code" href="../../da/d81/structatom.html#atomo10">mb</a>[pd].<a class="code" href="../../df/d7e/structmolbond.html#molbondo1">t</a>.<a class="code" href="../../d2/d4f/structmolindex.html#molindexo3">a</a>;
01092 printf(<span class="stringliteral">"\t\t\tTo %s (atom number %d)\n"</span>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo1">N</a>,A.<a class="code" href="../../db/dac/structassembly.html#assemblyo6">m</a>[tm][0].<a class="code" href="../../dc/d7f/structmolecule.html#moleculeo12">r</a>[tr].<a class="code" href="../../d0/d7e/structresidue.html#residueo9">a</a>[ta].<a class="code" href="../../da/d81/structatom.html#atomo0">n</a>);
01093 }
01094 }
01095 }
01096 }
01097 <span class="comment">//      -- MOLI[i] contains residue and atom info per each linear-numbered atom</span>
01098 <span class="comment">// -- set local torsions and angles</span>
01099 <span class="comment">// -- set connection tree after all that...</span>
01100 <span class="comment">//      -- check this tree against the amber tree info for sanity</span>
01101 <span class="comment">//int IPTRES=0,NSPM=0,NSPSOL=0,*NSP; // solvent/solute info &amp; #atoms per molecule</span>
01102 <span class="comment">//molbond *MB;</span>
01103 <span class="comment">//angle_index *MANG;</span>
01104 <span class="comment">//torsion_index *MTOR;</span>
01105 <span class="comment">//char **ATNAME,**TREECLASS,*RADTYPE;</span>
01106 <span class="comment">//double *R,*SC,*MASS; // radii and screening constants for IS, atom masses</span>
01107 <span class="comment">//fileset F;</span>
01108 <span class="comment">//</span>
01109 
01110 
01111 <span class="keywordflow">return</span> A;
01112 }
01113 
01114 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Aug 8 10:31:04 2008 for GLYLIB by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
